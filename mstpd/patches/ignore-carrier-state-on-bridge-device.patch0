Index: bridge_ctl.h
===================================================================
--- bridge_ctl.h	(revision 16)
+++ bridge_ctl.h	(working copy)
@@ -81,7 +81,7 @@
 
 int init_bridge_ops(void);
 
-int bridge_notify(int br_index, int if_index, bool newlink, bool up);
+int bridge_notify(int br_index, int if_index, bool newlink, unsigned flags);
 
 void bridge_bpdu_rcv(int ifindex, const unsigned char *data, int len);
 
Index: brmon.c
===================================================================
--- brmon.c	(revision 16)
+++ brmon.c	(working copy)
@@ -66,7 +66,7 @@
     int len = n->nlmsg_len;
     char b1[IFNAMSIZ];
     int af_family = ifi->ifi_family;
-    bool newlink, up;
+    bool newlink;
     int br_index;
 
     if(n->nlmsg_type == NLMSG_DONE)
@@ -154,12 +154,6 @@
     fflush(fp);
 
     newlink = (n->nlmsg_type == RTM_NEWLINK);
-    up = false;
-    if(newlink && tb[IFLA_OPERSTATE])
-    {
-        int state = *(uint8_t*)RTA_DATA(tb[IFLA_OPERSTATE]);
-        up = (state == IF_OPER_UP) || (state == IF_OPER_UNKNOWN);
-    }
 
     if(tb[IFLA_MASTER])
         br_index = *(int*)RTA_DATA(tb[IFLA_MASTER]);
@@ -168,7 +162,7 @@
     else
         br_index = -1;
 
-    bridge_notify(br_index, ifi->ifi_index, newlink, up);
+    bridge_notify(br_index, ifi->ifi_index, newlink, ifi->ifi_flags);
 
     return 0;
 }
Index: bridge_track.c
===================================================================
--- bridge_track.c	(revision 16)
+++ bridge_track.c	(working copy)
@@ -279,13 +279,15 @@
 }
 
 /* br_index == if_index means: interface is bridge master */
-int bridge_notify(int br_index, int if_index, bool newlink, bool up)
+int bridge_notify(int br_index, int if_index, bool newlink, unsigned flags)
 {
     port_t *ifc;
     bridge_t *br = NULL, *other_br;
+    bool up = !!(flags & IFF_UP);
+    bool running = up && (flags & IFF_RUNNING);
 
-    LOG("br_index %d, if_index %d, newlink %d, up %d",
-        br_index, if_index, newlink, up);
+    LOG("br_index %d, if_index %d, newlink %d, up %d, running %d",
+        br_index, if_index, newlink, up, running);
 
     if((br_index >= 0) && (br_index != if_index))
     {
@@ -296,9 +298,9 @@
             ERROR("Couldn't create data for bridge interface %d", br_index);
             return -1;
         }
-        int br_up = ethtool_get_link(br->sysdeps.name);
-        if(br_up >= 0)
-            set_br_up(br, !!br_up);
+        int br_flags = get_flags(br->sysdeps.name);
+        if(br_flags >= 0)
+            set_br_up(br, !!(flags & IFF_UP));
     }
 
     if(br)
@@ -336,7 +338,7 @@
             delete_if(ifc);
             return 0;
         }
-        set_if_up(ifc, up);	/* And speed and duplex */
+        set_if_up(ifc, running); /* And speed and duplex */
     }
     else
     { /* Interface is not a bridge slave */
Index: netif_utils.c
===================================================================
--- netif_utils.c	(revision 16)
+++ netif_utils.c	(working copy)
@@ -65,23 +65,17 @@
     return 0;
 }
 
-int ethtool_get_link(char *ifname)
+int get_flags(char *ifname)
 {
     struct ifreq ifr;
     memset(&ifr, 0, sizeof(ifr));
     strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
-    struct ethtool_value eval;
-
-    eval.cmd = ETHTOOL_GLINK;
-    ifr.ifr_data = (caddr_t)&eval;
-    if(0 > ioctl(netsock, SIOCETHTOOL, &ifr))
+    if(0 > ioctl(netsock, SIOCGIFFLAGS, &ifr))
     {
-        ERROR("Cannot get link status for %s: %m\n", ifname);
+        ERROR("%s: get interface flags failed: %m", ifname);
         return -1;
     }
-    if(eval.data)
-        return 1;
-    return 0;
+    return ifr.ifr_flags;
 }
 
 int ethtool_get_speed_duplex(char *ifname, int *speed, int *duplex)
Index: netif_utils.h
===================================================================
--- netif_utils.h	(revision 16)
+++ netif_utils.h	(working copy)
@@ -31,9 +31,9 @@
 int netsock_init(void);
 
 int get_hwaddr(char *ifname, unsigned char *hwaddr);
+int get_flags(char *ifname);
 
 int ethtool_get_speed_duplex(char *ifname, int *speed, int *duplex);
-int ethtool_get_link(char *ifname);
 
 bool is_bridge(char *if_name);
 
