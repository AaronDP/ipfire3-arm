
# Begin /etc/sysconfig/rc.site

# Set base directory information
RC_BASE="/etc"
RC_FUNCTIONS="${RC_BASE}/init.d/ipfire-functions"

# Location of network device scripts and config files
NETWORK_DEVICES="/etc/sysconfig/network-devices"

# Directory to store boot process accounting information
# Used for boot logging and interactive flag when rootfs
# is not writable
TEMPFS_MOUNT="${RC_BASE}/init.d/boottemp"

# Bootlogging (requires a tempfs mount)
BOOTLOG_ENAB="yes"

# Distro Information
DISTRO="IPFire" # The distro name
DISTRO_CONTACT="http://bugtracker.ipfire.org" # Bug report address
DISTRO_MINI="ipfire" # Short name used in filenames for distro config

# Define custom colors used in messages printed to the screen
BRACKET="\\033[1;34m" # Blue
FAILURE="\\033[1;31m" # Red
INFO="\\033[1;36m"    # Cyan
NORMAL="\\033[0;39m"  # Grey
SUCCESS="\\033[1;32m" # Green
WARNING="\\033[1;33m" # Yellow

# Prefix boot messages for easier reading on framebuffer consoles
PREFIX_SUCCESS=" ${SUCCESS}*${NORMAL} "
PREFIX_WARNING="${WARNING}**${NORMAL} "
PREFIX_FAILURE="${FAILURE}***${NORMAL}"

# Export varialbles so that they are inherited by the initscripts
export RC_BASE RC_FUNCTIONS NETWORK_DEVICES TEMPFS_MOUNT BOOTLOG_ENAB
export DISTRO DISTRO_CONTACT DISTRO_MINI
export BRACKET FAILURE INFO NORMAL SUCCESS WARNING
export PREFIX_SUCCESS PREFIX_WARNING PREFIX_FAILURE

# Interactive startup
iprompt="yes" # Wether to display the interactive boot promp
itime="2" # The ammount of time (in seconds) to display the prompt
dlen="29" # The total length of the distro welcome string
ilen="38" # The total length of the interactive message
welcome_message="Welcome to ${INFO}${DISTRO}${NORMAL}"
i_message="Press '${FAILURE}I${NORMAL}' to enter interactive startup"

# Error message displayed when a script's exit value is not zero
print_error_msg()
{
    # ${link} and ${error_value} are defined by the rc script
    echo -e "${FAILURE}FAILURE:  You should not be reading this error message."
    echo -e ""
    echo -e -n "${FAILURE}It means that an unforseen error took place in"
    echo -e -n "${INFO} ${link}"
    echo -e "${FAILURE},"
    echo -e "${FAILURE}which exited with a return value of ${error_value}."
    echo -e ""
    echo -e -n "${FAILURE}If you are able to track this error down to a bug"
    echo -e "${FAILURE}in one of the files"
    echo -e -n "provided by ${INFO}${DISTRO}${FAILURE}, "
    echo -e -n "${FAILURE}please be so kind to inform us at "
    echo -e "${INFO}${DISTRO_CONTACT}${FAILURE}.${NORMAL}"
    echo -e ""
    echo -e "${INFO}Press Enter to continue..."
    echo -e "${NORMAL}"
    read ENTER
}

# End /etc/sysconfig/rc.site

# Begin /etc/sysconfig/rc

# Author: DJ Lucas - dj@linuxfromscratch.org
# Version: 1.0 LSB V.3.1

# Global variable inherited by initscripts are in caps
# Local variables for the rc script are in lowercase

# This sets default terminal options.
# stty sane - this has been removed as nobody recalls
# the reason for it in the first place - if no problems arize,
# then it will be removed completely at a later date.

# Setup default values for the environment
umask 022
PATH="/bin:/sbin"

# Find current screen size
if [ -z "${COLUMNS}" ]; then
        COLUMNS=$(stty size)
        COLUMNS=${COLUMNS##* }
fi

# When using remote connections, such as a serial port, stty size returns 0
if [ "${COLUMNS}" = "0" ]; then
        COLUMNS=80
fi

## Measurements for positioning result messages
COL=$((${COLUMNS} - 8))
WCOL=$((${COL} - 2))

# Set Cursur Position Commands, used via echo -e
SET_COL="\\033[${COL}G"      # at the $COL char
SET_WCOL="\\033[${WCOL}G"    # at the $WCOL char
CURS_UP="\\033[1A\\033[0G"   # Up one line, at the 0'th char

# Bootlogging and interactive startup require a valid tempfs mount
# if this mount is not present, disable them
if [ "${TEMPFS_MOUNT}" = "" -o ! -d "${TEMPFS_MOUNT}" ]; then
    TEMPFS_MOUNT=""
    iprompt=""
    BOOTLOG_ENAB=""
fi

# Export the environment variables so they are inherited by the scripts
export PATH SET_COL SET_WCOL CURS_UP TEMPFS_MOUNT BOOTLOG_ENAB RUNLEVEL

# End /etc/sysconfig/rc

# Begin /lib/lsb/init-funtions

# Provides initialization funtions as defined by the Linux Standard Base
# specification, version 3.1.0

################################################################################
# start_daemon()                                                               #
# Usage: start_daemon [-f] [-n nicelevel] [-p pidfile] pathname [args...]      #
#                                                                              #
# Purpose: This runs the specified program as a daemon                         #
#                                                                              #
# Inputs: -f: (force) run the program even if it is already running.           #
#         -n nicelevel: specify a nice level. See 'man nice(1)'.               #
#         -p pidfile: use the specified file to determine PIDs.                #
#         pathname: the complete path to the specified program                 #
#         args: additional arguments passed to the program (pathname)          #
#                                                                              #
# Return values (as defined by LSB exit codes):                                #
#       0 - program is running or service is OK                                #
#       1 - generic or unspecified error                                       #
#       2 - invalid or excessive argument(s)                                   #
#       5 - program is not installed                                           #
################################################################################
start_daemon()
{
    local force=""
    local nice="0"
    local pidfile=""
    local pidlist=""
    local retval=""

    # Process arguments
    while true
    do
        case "${1}" in

            -f)
                force="1"
                shift 1
                ;;

            -n)
                nice="${2}"
                shift 2
                ;;

            -p)
                pidfile="${2}"
                shift 2
                ;;

            -*)
                return 2
                ;;

            *)
                program="${1}"
                break
                ;;
        esac
    done

    # Check for a valid program
    if [ ! -e "${program}" ]
    then
        return 5
    fi

    # Execute
    if [ -z "${force}" ]
    then
        if [ -z "${pidfile}" ]
        then
            # determine the pid by discovery
            pidlist=`pidofproc "${1}"`
            retval="${?}"
        else
            # The PID file contains the needed PIDs
            # Note that by LSB requirement, the path must be given to pidofproc,
            # however, it is not used by the current implementation or standard.
            pidlist=`pidofproc -p "${pidfile}" "${1}"`
            retval="${?}"
        fi

        # return a value ONLY 
        # It is the init script's (or distribution's functions) responsibilty
        # to log messages!
        case "${retval}" in

            0)
                # program is already running correctly, this is a 
                # succesful start.
                return 0
                ;;

            1)
                # program is not running, but an invalid pid file exists
                # remove the pid file and continue
                rm -f "${pidfile}"
                ;;

            3)
                # program is not running and no pidfile exists
                # do nothing here, let start_deamon continue.
                ;;

            *)
                # Others as returned by status values shall not be interpreted
                # and returned as an unspecified error.
                return 1
                ;;
        esac
    fi

    # do the start!
    nice -n "${nice}" "${@}"

}

################################################################################
# killproc()                                                                   #
# Usage: killproc [-p pidfile] pathname [signal]                               #
#                                                                              #
# Purpose: Send control signals to running processes                           #
#                                                                              #
# Inputs: -p pidfile, uses the specified pidfile                               #
#         pathname, pathname to the specified program                          #
#         signal, send this signal to pathname                                 #
#                                                                              #
# Return values (as defined by LSB exit codes):                                #
#       0 - program (pathname) has stopped/is already stopped or a             #
#           running program has been sent specified signal and stopped         #
#           successfully                                                       #
#       1 - generic or unspecified error                                       #
#       2 - invalid or excessive argument(s)                                   #
#       5 - program is not installed                                           #
#       7 - program is not running and a signal was supplied                   #
################################################################################
killproc()
{
    local pidfile
    local program
    local prefix
    local progname
    local signal="-TERM"
    local fallback="-KILL"
    local nosig
    local pidlist
    local retval
    local pid
    local delay="30"
    local piddead
    local dtime

    # Process arguments
    while true
    do
        case "${1}" in

            -p)
                pidfile="${2}"
                shift 2
                ;;
 
             *)
                 program="${1}"
                 if [ -n "${2}" ]
                 then
                     signal="${2}"
                     fallback=""
                 else
                     nosig=1
                 fi

                 # error on additional arguments
                 if [ -n "${3}" ]
                 then
                     return 2
                 else 
                     break
                 fi                 
                 ;;
        esac
    done

    # Check for a valid program
    if [ ! -e "${program}" ]
    then
        return 5
    fi

    # Check for a valid signal
    check_signal "${signal}"
    if [ "${?}" != "0" ]
    then
        return 2
    fi

    # Get a list of pids
    if [ -z "${pidfile}" ]
    then
        # determine the pid by discovery
        pidlist=`pidofproc "${1}"`
        retval="${?}"
    else
        # The PID file contains the needed PIDs
        # Note that by LSB requirement, the path must be given to pidofproc,
        # however, it is not used by the current implementation or standard.
        pidlist=`pidofproc -p "${pidfile}" "${1}"`
        retval="${?}"
    fi

    # return a value ONLY
    # It is the init script's (or distribution's functions) responsibilty
    # to log messages!
    case "${retval}" in

        0)
            # program is running correctly
            # do nothing here, let killproc continue.
            ;;

        1)
            # program is not running, but an invalid pid file exists
            # remove the pid file.
            rm -f "${pidfile}"
            # this is only a success if no signal was passed.
            if [ -n "${nosig}" ]
            then
                return 0
            else
                return 7
            fi
            ;;

        3)
            # program is not running and no pidfile exists
            # this is only a success if no signal was passed.
            if [ -n "${nosig}" ]
            then
                return 0
            else
                return 7
            fi
            ;;

        *)
            # Others as returned by status values shall not be interpreted
            # and returned as an unspecified error.
            return 1
            ;;
    esac

    # perform different actions for exit signals and control signals
    check_sig_type "${signal}"
    if [ "${?}" -eq "0" ] # signal is used to terminate the program
    then
        # account for empty pidlist (pid file still exists and nosignal was given)
        if [ "${pidlist}" != "" ]; then
            #kill the list of pids
            for pid in ${pidlist}
            do
                kill -0 "${pid}" 2> /dev/null
                if [ "${?}" -ne "0" ]; then
                    # process is dead, continue to next and assume all is well
                    continue
                else
                    kill "${signal}" "${pid}" 2> /dev/null
                    # Wait up to ${delay}/10 seconds to for "${pid}" to 
                    # terminate in 10ths of a second
                    while [ "${delay}" != "0" ]
                    do
                        kill -0 "${pid}" 2> /dev/null || piddead="1"
                        if [ "${piddead}" = "1" ]
                        then
                            break
                        fi
                        sleep 0.1
                        delay="$(( ${delay} - 1 ))"
                    done
                    # If a fallback is set, and program is still running, then
                    # use the fallback
                    if [ -n "${fallback}" -a "${piddead}" != "1" ]
                    then
                        kill "${fallback}" "${pid}" 2> /dev/null
                        sleep 1
                        # Check again, and fail if still running
                        kill -0 "${pid}" 2> /dev/null && return 1
                    else
                        # just check one last time and if still alive, fail
                        sleep 1
                        kill -0 "${pid}" 2> /dev/null && return 1
                    fi
                fi
            done
        fi

        # Check for and remove stale PID files.
        if [ -z "${pidfile}" ]
        then
            #find the basename of $program
            prefix=`echo "${program}" | sed 's/[^/]*$//'`
            progname=`echo "${program}" | sed "s@${prefix}@@"`
            if [ -e "/var/run/${progname}.pid" ]
            then
                rm -f "/var/run/${progname}.pid" 2> /dev/null
            fi
        else
            if [ -e "${pidfile}" ]
            then
                rm -f "${pidfile}" 2> /dev/null
            fi
        fi

    # For signals that do not expect a program to exit, simply
    # let kill do it's job, and evaluate kills return for value
    else # check_sig_type - signal is not used to terminate program
        for pid in ${pidlist}
        do
            kill "${signal}" "${pid}"
            if [ "${?}" -ne "0" ]; then
                return 1
            fi
        done
    fi
}

################################################################################
# pidofproc()                                                                  #
# Usage: pidofproc [-p pidfile] pathname                                       #
#                                                                              #
# Purpose: This function returns one or more pid(s) for a particular daemon    #
#                                                                              #
# Inputs: -p pidfile, use the specified pidfile instead of pidof               #
#         pathname, path to the specified program                              #
#                                                                              #
# Return values (as defined by LSB status codes):                              #
#       0 - Success (PIDs to stdout)                                           #
#       1 - Program is dead, PID file still exists (remaining PIDs output)     #
#       3 - Program is not running (no output)                                 #
################################################################################
pidofproc()
{

local pidfile
local program
local prefix
local progname
local pidlist
local lpids
local exitstatus="0"

    # Process arguments
    while true
    do
        case "${1}" in

            -p)
                pidfile="${2}"
                shift 2
                ;;

            *)
                program="${1}"
                if [ -n "${2}" ]
                then
                    # Too many arguments
                    # Since this is status, return unknown
                    return 4
                else
                    break
                fi
                ;;
        esac
    done

    # If a PID file is not specified, try and find one.
    if [ -z "${pidfile}" ]
    then
        # get the program's basename
        prefix=`echo "${program}" | sed 's/[^/]*$//'`
        progname=`echo "${program}" | sed "s@${prefix}@@"`
        # if a PID file exists with that name, assume that is it.
        if [ -e "/var/run/${progname}.pid" ]
        then
            pidfile="/var/run/${progname}.pid"
        fi
    fi

    # if a PID file is set and exists, use it.
    if [ -n "${pidfile}" -a -e "${pidfile}" ]
    then
        # use the value in the first line of the pidfile
        pidlist=`/bin/head -n1 "${pidfile}"`
        # This can optionally be written as 'sed 1q' to repalce 'head -n1'
        # should LFS move /bin/head to /usr/bin/head
    else
        # use pidof
        pidlist=`pidof "${program}"`
    fi

    # Figure out if all listed PIDs are running.
    for pid in ${pidlist}
    do
        kill -0 ${pid} 2> /dev/null
        if [ "${?}" = "0" ]; then
            lpids="${pids}${pid} "
        else
            exitstatus="1"
        fi
    done

    if [ -z "${lpids}" -a ! -f "${pidfile}" ]; then
        return 3
    else
        echo "${lpids}"
        return "${exitstatus}"
    fi
}
################################################################################
# log_success_msg()                                                            #
# Usage: log_success_msg [$MESSAGE | "message"]                                #
#                                                                              #
# Purpose: Print a successful status message to the screen and optionally      #
#          a boot log file.                                                    #
#                                                                              #
# Inputs: accepts one string value, either a quoted string or optionally       #
#         the value of $MESSAGE if set in the running environment.             #
#                                                                              #
# Return values: Not used                                                      #
################################################################################
log_success_msg()
{
    echo -n -e "${PREFIX_SUCCESS}${@}"
    echo -e "${SET_COL}${BRACKET}[${SUCCESS}  OK  ${BRACKET}]${NORMAL}"
    if [ "${BOOTLOG_ENAB}" = "yes" ]; then
        if [ $( hostname ) = "(none)" ]; then
            BTTIMESPEC=""
        else
            BTTIMESPEC="$(echo `date +"%b %d %T"` `hostname`) "
        fi
        echo "${BTTIMESPEC}bootlog: ${@} Successful" >> "${TEMPFS_MOUNT}/.bootlog"
    fi
    return 0
}

################################################################################
# log_failure_msg()                                                            #
# Usage: log_failure_msg [$MESSAGE | "message"]                                #
#                                                                              #
# Purpose: Print a failure status message to the screen and optionally         #
#          a boot log file.                                                    #
#                                                                              #
# Inputs: accepts one string value, either a quoted string or optionally       #
#         the value of $MESSAGE if set in the running environment.             #
#                                                                              #
# Return values: Not used                                                      #
################################################################################
log_failure_msg()
{
    echo -n -e "${PREFIX_FAILURE}${@}"
    echo -e "${SET_COL}${BRACKET}[${FAILURE} FAIL ${BRACKET}]${NORMAL}"
    if [ "${BOOTLOG_ENAB}" = "yes" ]; then
        if [ $( hostname ) = "(none)" ]; then
            BTTIMESPEC=""
        else
            BTTIMESPEC="$(echo `date +"%b %d %T"` `hostname`) "
        fi
        echo "${BTTIMESPEC}bootlog: ${@} Failed!" >> "${TEMPFS_MOUNT}/.bootlog"
    fi
    return 0
}

################################################################################
# log_warning_msg()                                                            #
# Usage: log_warning_msg [$MESSAGE | "message"]                                #
#                                                                              #
# Purpose: Print a warning status message to the screen and optionally         #
#          a boot log file.                                                    #
#                                                                              #
# Inputs: accepts one string value, either a quoted string or optionally       #
#         the value of $MESSAGE if set in the running environment.             #
#                                                                              #
# Return values: Not used                                                      #
################################################################################
log_warning_msg()
{
    echo -n -e "${PREFIX_WARNING}${@}"
    echo -e "${SET_COL}${BRACKET}[${WARNING} WARN ${BRACKET}]${NORMAL}"
    if [ "${BOOTLOG_ENAB}" = "yes" ]; then
        if [ $( hostname ) = "(none)" ]; then
            BTTIMESPEC=""
        else
            BTTIMESPEC="$(echo `date +"%b %d %T"` `hostname`) "
        fi
        echo "${BTTIMESPEC}bootlog: ${@} Warning" >> "${TEMPFS_MOUNT}/.bootlog"
    fi
    return 0
}

################################################################################
# check_signal()                                                               #
# Usage: check_signal [ -{signal} | {signal} ]                                 #
#                                                                              #
# Purpose: Check for a valid signal.  This is not defined by any LSB draft,    #
#          however, it is required to check the signals to determine if the    #
#          signals chosen are invalid arguments to the other functions.        #
#                                                                              #
# Inputs: accepts a single string value in the form or -{signal} or {signal}   #
#                                                                              #
# Return values:                                                               #
#       0 - Success (signal is valid                                           #
#       1 - Signal is not valid                                                #
################################################################################
check_signal()
{
    local valsig

    # Add error handling for invalid signals
    valsig="-ALRM -HUP -INT -KILL -PIPE -POLL -PROF -TERM -USR1 -USR2"
    valsig="${valsig} -VTALRM -STKFLT -PWR -WINCH -CHLD -URG -TSTP -TTIN"
    valsig="${valsig} -TTOU -STOP -CONT -ABRT -FPE -ILL -QUIT -SEGV -TRAP"
    valsig="${valsig} -SYS -EMT -BUS -XCPU -XFSZ -0 -1 -2 -3 -4 -5 -6 -8 -9"
    valsig="${valsig} -11 -13 -14 -15"

    echo "${valsig}" | grep -- " ${1} " > /dev/null
    if [ "${?}" = "0" ]
    then
        return 0
    else
        return 1
    fi
}


################################################################################
# check_sig_type()                                                             #
# Usage: check_signal [ -{signal} | {signal} ]                                 #
#                                                                              #
# Purpose: Check if signal is a program termination signal or a control signal #
#          This is not defined by any LSB draft, however, it is required to    #
#          check the signals to determine if they are intended to end a        #
#          program or simply to control it.                                    #
#                                                                              #
# Inputs: accepts a single string value in the form or -{signal} or {signal}   #
#                                                                              #
# Return values:                                                               #
#       0 - Signal is used for program termination                             #
#       1 - Signal is used for program control                                 #
################################################################################
check_sig_type()
{
    local valsig

    # The list of termination signals (limited to generally used items)
    valsig="-ALRM -INT -KILL -TERM -PWR -STOP -ABRT -QUIT -2 -3 -6 -9 -14 -15"

    echo "${valsig}" | grep -- " ${1} " > /dev/null
    if [ "${?}" = "0" ]
    then
        return 0
    else
        return 1
    fi
}

# End /lib/lsb/init-functions
# Begin /etc/init.d/ipfire-functions
# Provides LFS specific functions for LSB style bootscripts

################################# chkstat() ###################################
# chk_stat checks the status of a script by checking for both a binary file   #
# to execute, and if set, a config file that may be needed for the program    #
# to run successfully.  The calling script will exit with a return value of 5 #
# if the binary does not exist, and a value of 6 if the needed config file is #
# unavailable as per LSB requirements.  This function accepts zero, one, or   #
# two string arguments.  If arguments are passed, the first must be a bin     #
# file.  If a second argument is passed, it is interpreted as the config      #
# file.  Optionally, zero arguments can be passed if BIN_FILE, and optinally  #
# CONFIG_FILE are set in the calling script.                                  #
###############################################################################
chk_stat()
{
    if [ "${#}" -gt "0" -a "${#}" -lt "3" ]; then
        BIN_FILE="${1}"
        if [ -z "${2}" ]; then
            CONFIG_FILE=""
        else
            CONFIG_FILE="${2}"
        fi
    elif [ -z "${BIN_FILE}" ]; then
            echo "Usage: 'chk_stat BIN_FILE CONFIG_FILE'"
            exit 1 # Generic Error
    fi

    if [ ! -e "${BIN_FILE}" ]; then
        log_failure_msg "${BIN_FILE} not installed" &&
        exit 5
    fi

    if [ ! -z "${CONFIG_FILE}" ]; then
        if [ ! -e "${CONFIG_FILE}" ]; then
            log_failure_msg "${CONFIG_FILE} does not exist" &&
            exit 6
        fi
    fi
}

################################ loadproc() ###################################
# loadproc is just a wraper to start_daemon for simple scripts, which will    #
# require no arguments if $BIN_FILE is set.                                   #
###############################################################################
loadproc()
{
    start_daemon "${BIN_FILE}" "${@}"
}

################################ endproc() ####################################
# endproc, like loadproc, is just a wraper to killproc for simplicity and is  #
# dependent on $BIN_FILE being set.                                           #
###############################################################################
endproc()
{
    killproc "${BIN_FILE}" "${@}"
}

############################### statusproc() ##################################
# statusproc checks the status of a particular binary and displays the        #
# appropriate message (running or not running) and exits on the return value  #
# of pidofproc.  This function accepts two string arguments or zero arguments #
# if BIN_FILE and MESSAGE are set, else it requires the bin file as the first #
# argument, and the message as the second.  Both must be enclosed in quotes.  #
###############################################################################
statusproc()
{
    if [ "${#}" -gt "0" -a "${#}" -lt "3" ]; then
        BIN_FILE="${1}"
        MESSAGE="${2}"
    elif [ -z "${BIN_FILE}" -o -z "${MESSAGE}" ]; then
        echo "Usage: 'statusproc BIN_FILE MESSAGE'"
        exit 1 # Generic Error
    fi

    pidlist=`pidofproc "${BIN_FILE}"`
    STATUS=$?
    echo "Checking ${MESSAGE} status:"
    if [ "${STATUS}" = "0" ]; then
        log_success_msg "Running with PID(s) ${pidlist}"
    else
        
        log_warning_msg "Not running!"
    fi

    return "${STATUS}"
}

############################### reloadproc() ##################################
# reloadproc sends a HUP signal to the running program (relaod configuration) #
# It optionally, using the -force switch, checks the status of a particular   #
# program and starts it if it is not already running. This function accepts   #
# one optional switch (must be the first argument), and either two, or zero   #
# string arguments.  If BIN_FILE and MESSAGE are set in the script's          #
# environment, it will use those values,  else it requires the bin file as    #
# the first argument (following -force if used), and the message as the       #
# second. Both must be enclosed in quotes. If the force option is used, it    #
# follows the LSB definition of 'force-reload' - the program is started if    #
# not already running.                                                        #
###############################################################################
reloadproc()
{
    local force="0"
    if [ "${#}" -gt "0" -a "${1}" = "-force" ]; then
        force="1"
        shift 1
    fi

    if [ "${#}" -gt "0" -a "${#}" -lt "3" ]; then
        BIN_FILE="${1}"
        MESSAGE="${2}"
    elif [ -z "${BIN_FILE}" -o -z "${MESSAGE}" ]; then
        echo "Usage: 'reloadproc BIN_FILE MESSAGE'"
        exit 1 # Generic Error
    fi

    

}

############################## evaluate_retval() ###############################
# evaluate_retval requires that you pass exactly one evaluation parameter of   #
# (start, stop, other) based on the previous action that is being evaluated.   #
# This function is intended for use with start_daemon and killproc to          #
# interpret the LSB exit codes properly, othewise the checks only for success  #
# or failure.                                                                  #
################################################################################
evaluate_retval()
{
    local error_value="${?}"

    # Handle LSB defined return values
    case "${1}" in

      start)
        case "${error_value}" in
          0)
            log_success_msg "Starting ${MESSAGE} "
            return "${error_value}"
          ;;
          2)
            log_failure_msg "Starting ${MESSAGE} Error: Invalid argument!"
            return "${error_value}"
          ;;
          5)
            log_failure_msg "Starting ${MESSAGE} Error: Not available!"
            return "${error_value}"
          ;;
          *)
            log_failure_msg "Starting ${MESSAGE} Error: General failure!"
            return "${error_value}"
          ;;
        esac
      ;;

      stop)
        case "${error_value}" in
          0)
            log_success_msg "Stopping ${MESSAGE} "
            return "${error_value}"
            ;;
          2)
            log_failure_msg "Stopping ${MESSAGE} Error: Invalid argument!"
            return "${error_value}"
            ;;
          5)
            log_failure_msg "Stopping ${MESSAGE} Error: Not available!"
            return "${error_value}"
            ;;
          7)
            log_warning_msg "Stopping ${MESSAGE} Warning: Not running!"
            return "${error_value}"
            ;;
          *)
            log_failure_msg "Stopping ${MESSAGE} Error: General failure!"
            return "${error_value}"
            ;;
          esac
       ;;

       force-reload)
         message="Forcefully reloading "
       ;;

       reload)
         message="Reloading "
       ;;

       restart)
         message="Restarting "
       ;;

       try-restart)
         message="Trying restart "
       ;;

       standard)
         # $message or $MESSAGE must be set, but not both in order
         # to use the 'standard' target.
       ;;
    esac

    # Print messages for the generic force-reload, reload, restart, 
    # and try-restart targets
    if [ "${error_value}" = "0" ]
    then
        log_success_msg "${message}${MESSAGE} "
        return "${error_value}"
    else
        log_failure_msg "${message}${MESSAGE} "
        return "${error_value}"
    fi
}

