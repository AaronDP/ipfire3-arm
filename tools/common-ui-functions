#!/bin/bash

## Screen Dimentions
# Find current screen size
if [ -z "${COLUMNS}" ]; then
	COLUMNS=$(stty size 2>/dev/null)
	COLUMNS=${COLUMNS##* }
fi

# When using remote connections, such as a serial port, stty size returns 0
if [ "${COLUMNS}" = "0" ]; then
	COLUMNS=80
fi

## Set Cursur Position Commands, used via echo -e
SET_RESULT_COL="\\033[${RESULT_COL}G"
SET_TIME_COL="\\033[${TIME_COL}G"
SET_VER_COL="\\033[${VER_COL}G"
SET_OPT_COL="\\033[${OPT_COL}G"

# Normal colors
CLR_NORM_BLK="\\033[0;30m"    # black
CLR_NORM_RED="\\033[0;31m"    # red
CLR_NORM_GRN="\\033[0;32m"    # green
CLR_NORM_YEL="\\033[0;33m"    # yellow
CLR_NORM_BLU="\\033[0;34m"    # blue
CLR_NORM_MAG="\\033[0;35m"    # magenta
CLR_NORM_CYN="\\033[0;36m"    # cyan
CLR_NORM_WHT="\\033[0;37m"    # white
CLR_NORM_GRY="\\033[0;39m"    # grey

# Emphased colors
CLR_BOLD_BLK="\\033[1;30m"    # black
CLR_BOLD_RED="\\033[1;31m"    # red
CLR_BOLD_GRN="\\033[1;32m"    # green
CLR_BOLD_YEL="\\033[1;33m"    # yellow
CLR_BOLD_BLU="\\033[1;34m"    # blue
CLR_BOLD_MAG="\\033[1;35m"    # magenta
CLR_BOLD_CYN="\\033[1;36m"    # cyan
CLR_BOLD_WHT="\\033[1;37m"    # white
CLR_BOLD_GRY="\\033[1;39m"    # grey

# Background colors
CLR_BACK_BLK="\\033[40m"      # black
CLR_BACK_RED="\\033[41m"      # red
CLR_BACK_GRN="\\033[42m"      # green
CLR_BACK_YEL="\\033[43m"      # yellow
CLR_BACK_BLU="\\033[44m"      # blue
CLR_BACK_MAG="\\033[45m"      # magenta
CLR_BACK_CYN="\\033[46m"      # cyan
CLR_BACK_WHT="\\033[47m"      # white

# Action colors
BOLD=$CLR_BOLD_GRY
DONE=$CLR_BOLD_GRN
SKIP=$CLR_BOLD_BLU
WARN=$CLR_BOLD_YEL
FAIL=$CLR_BOLD_RED
NORMAL=$CLR_NORM_GRY
ERROR=$CLR_BOLD_RED

# Color hooks
BRACKET_L="${CLR_BOLD_BLU}[${NORMAL}"
BRACKET_R="${CLR_BOLD_BLU}]${NORMAL}"

function log() {
	if [ -z "${LOGFILE}" ]; then
		return 0
	fi

	local facility=${1}
	shift
	
	if [ "${facility}" == "DEBUG" ] && [ "${DEBUG}" != "1" ]; then
		return 0
	fi

	printf "%s naoki[%5d] %8s %s\n" "$(date -u)" "$$" "${facility}" "$@" >> ${LOGFILE}
}

function msg() {
	log MESSAGE "$@"
	echo -e "$@"
}

function error() {
	log ERROR "$@"
	echo -e "${ERROR}ERROR${NORMAL}  : $@" >&2
}

function warning() {
	log WARNING "$@"
	echo -e "${WARN}WARNING${NORMAL}: $@" >&2
}

function exiterror() {
	ERROR=1
	error $@
}

function format() {
	local max_length=50
	local line="# "
	local length=0

	for word in $@; do
		length=$(expr ${length} + ${#word})
		if [ "${length}" -ge "${max_length}" ]; then
			printf "${line}\n"
			line="# ${word} "
			length=${#word}
		else
			line="${line}${word} "
		fi
		#echo "-- ($word) $LINE"
	done
	printf "${line}\n"
}
