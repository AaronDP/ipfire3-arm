#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2007  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

check_common() {
	local NAME=$1
	if [ -n "$3" ]; then
		local RVER=$2
		local COMMAND=$3
	else
		local COMMAND=$2
	fi
	
	local EXTRA=$4
	
	RANDOM=$$
	TMPFILE=/tmp/ipfire-check-$RANDOM
	
	echo -ne "${BOLD}Checking for $NAME${NORMAL}"
	
	[ -n "$RVER" ] && echo -n " (Requires at least $RVER)"
	
	bash -c "$COMMAND" >$TMPFILE 2>&1
	
	if ! grep -q "command not found" < $TMPFILE; then
		beautify message DONE
	else
		rm -f $TMPFILE 2>/dev/null
		exiterror "$NAME not found!"
	fi
	
	[ -n "$EXTRA" ] && echo -n "$EXTRA"
	
	cat $TMPFILE
	rm -f $TMPFILE 2>/dev/null
	echo # Empty line
}

check_toolchain() {	
	check_common "GNU Bash"		"2.05a"		"bash --version | head -n1 | cut -d\" \" -f2-4"
	check_common "/bin/sh links bash?"		"if ! which sh; then echo \"command not found\"; fi"
	check_common "GNU Binutils"	"2.12"		"ld --version | head -n1 | cut -d\" \" -f3-" "Binutils: "
	check_common "GNU Bison"	"1.875"		"bison --version | head -n1"
	#check_common "/usr/bin/yacc links bison?"	"if ! which yacc; then echo \"command not found\"; fi"
	check_common "Bzip2"		"1.0.2"		"bzip2 --version 2>&1 < /dev/null | head -n1 | cut -d\" \" -f1,6-"
	check_common "Coreutils"	"5.0"		"chown --version | head -n1 | cut -d\")\" -f2" "Coreutils:"
	check_common "Diffutils"	"2.8"		"diff --version | head -n1"
	check_common "Findutils"	"4.1.20"	"find --version | head -n1"
	check_common "GNU awk"		"3.0"		"gawk --version | head -n1"
	check_common "/bin/awk links gawk?"		"if ! which awk; then echo \"command not found\"; fi"
	check_common "GNU CC"		"3.0.1"		"gcc --version | head -n1"
	check_common "GNU libc"		"2.2.5"		"/lib/libc.so.6 | head -n1 | cut -d\" \" -f1-7"
	check_common "GNU Grep"		"2.5"		"grep --version | head -n1"
	check_common "GNU zip"		"1.2.4"		"gzip --version | head -n1"
	check_common "Linux 2.6"	"2.6.x"		"uname -r" "Linux: "
	check_common "GNU make"		"3.79.1"	"make --version | head -n1"
	check_common "Patch"		"2.5.4"		"patch --version | head -n1"
	check_common "GNU sed"		"3.0.2"		"sed --version | head -n1"
	check_common "GNU tar"		"1.14"		"tar --version | head -n1"
	check_common "GNU Texinfo"	"4.8"		"makeinfo --version | head -n1"
	check_common "GNU m4"		"1.4.8"		"m4 --version | head -n1"
}

check_build() {
	check_common "GNU make"		"3.79.1"	"make --version | head -n1"
	check_common "GNU wget"				"wget --version | head -n1"
	check_common "Git"				"git --version"
	check_common "GNU which"			"which --version | head -n1"
}

check_rootfiles() {
	ACTION=$1

	echo -n " Running rootfile checks"

	case "$ACTION" in
		--fix)
			echo -n " and fix"

			# Remove leading pluses and replace them by '#'
			sed -e "s/^+/#/g" -i $BASEDIR/src/rootfiles/*/*
			;;
		"")
			: # If no option was given we do nothing.
			;;
		*)
			exiterror "This is not a valid option: $ACTION"
			;;
	esac

	echo "..." # End the line

	echo -n "  Searching for leading slashes..."
	if grep -n ^/ $BASEDIR/src/rootfiles/*/*; then
		exiterror "Please check your rootfiles! There are leading slashes."
	else
		beautify message DONE
	fi

	echo -n "  Searching for leading pluses..."
	if grep -n ^+ $BASEDIR/src/rootfiles/*/*; then
		exiterror "Please check your rootfiles for leading pluses."
	else
		beautify message DONE
	fi

	echo -n "  Searching for emtpy lines..."
	if grep -n ^$ $BASEDIR/src/rootfiles/*/*; then
		exiterror "Please check your rootfiles for empty lines."
	else
		beautify message DONE
	fi

}

check_code() {
    ACTION=$1
    ARGS="--recurse"

    echo -n " Running code checks"

	case "$ACTION" in
		--fix)
			echo -n " and fix"
			;;
		"")
			ARGS+=" --dryrun"
			;;
		*)
			exiterror "This is not a valid option: $ACTION"
			;;
	esac
	
	echo -n "..." # End the line

    python $BASEDIR/tools/code-beautify $ARGS $BASEDIR/{config,doc,lfs,src,tools}
    if [ "$?" -eq "0" ]; then
        beautify message DONE
    else
        beautify message FAIL
        exit 1
    fi
}

check_sanity() {

	echo "Checking sanity of working directory..."

	check_rootfiles $*
	check_code $*

}

check_user() {
	if [ -z $IPFIRE_USER ]; then
		echo -n "You have to setup IPFIRE_USER first. See .config for details."
		beautify message FAIL
		exit 1
	fi
}

check_loop() {
	for i in $(seq 0 7); do
		if [ -e /dev/loop/$i ] || [ -e /dev/loop$i ]; then
			return 0
		fi
	done
	return 1
}

CPU_FLAGS=$(grep ^flags /proc/cpuinfo)
check_cpu() {
	FLAG=$1;
	grep -q $FLAG <<< $CPU_FLAGS
	return $?
}

check_supported_target() {
	local FLAGS
	if [ "$1" = "via-c7" ]; then
		FLAGS="sse sse2 pni"
	elif [ "$1" = "via-c3" ]; then
		FLAGS="3dnow"
	fi
	for j in $FLAGS; do
		if ! check_cpu $j; then
			echo "Your system doesn't support needed cpu feature \"$j\" to build target $1." >&2
			return 1
		fi
	done
	return 0
}

check_supported_targets() {
	for i in ${1-$POSSIBLE_TARGETS}; do
		check_supported_target $i 2>/dev/null
		[ "$?" -eq "0" ] && echo -n "$i "
	done
	echo # new line
}
