#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2008  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

ccache_stats() {
	if [ -e $BASEDIR/ccache ]; then
		PATH=$PATH:build_${TARGET}/${TOOLS_DIR}/usr/bin \
		CCACHE_DIR=${BASEDIR}/ccache \
		ccache -s
	else
		echo -n "You can't access the statistics if you didn't run ./make.sh build"
		beautify message FAIL
	fi
}

distcc_mon() {

	# run gnome thing if we can...
	if [ -n "$DISPLAY" ]; then
		monitor=$(which distccmon-gnome 2>/dev/null)
		if [ -n "$monitor" ]; then
			DISTCC_DIR=$BASEDIR/distcc $monitor &
			return 0
		fi
	fi

	INTERVAL=1 # in seconds

	if [ -e $BASEDIR/distcc ]; then
		while sleep $INTERVAL; do
			clear
			echo "$NAME - Distcc monitor - Cancel with ctrl+c"
			echo
			PATH=$PATH:build_${TARGET}/${TOOLS_DIR}/usr/bin \
			DISTCC_DIR=${BASEDIR}/distcc \
			distccmon-text
		done
	else
		echo -n "You can't access the statistics if you didn't run ./make.sh build"
		beautify message FAIL
	fi
}

distccd_start() {
	echo -n "Running distcc daemon"

	if [ "$DISTCC_PORT" == "0" ]; then
		beautify message DISA
		return
	fi

	TOOLS_DIR=$TOOLS_DIR DISTCC_PORT=$DISTCC_PORT DISTCC_JOBS=$DISTCC_JOBS \
		LOGFILE=$BASEDIR/log_${TARGET}/_build.00-distccd.log \
		$BASEDIR/tools/make-compilers &
	if [ "$?" -eq "0" ]; then
		beautify message DONE
	else
		beautify message FAIL
	fi
}

distccd_stop() {
	echo -n "Stopping distcc daemon"
	killall distccd &>/dev/null
	if [ "$?" -eq "0" ]; then
		beautify message DONE
	else
		beautify message FAIL
	fi
}

distccd_restart() {
	distccd_stop
	distccd_start
}

distcc_get_hosts() {
	if [ -n "$DISTCC_HOSTS" ]; then
		logger --distcc "[INFO] Using local hosts: $DISTCC_HOSTS"
		echo "$DISTCC_HOSTS" > $BASEDIR/distcc/hosts
		return 0
	fi
	logger --distcc "[INFO] Getting hosts..."
	for i in $($BASEDIR/tools/buildspy uuid=$UUID action=get distcc=raw); do
		logger --distcc "[INFO]  Got host: $i"
		echo "$i" >> $BASEDIR/distcc/hosts_new
	done
	[ -s "$BASEDIR/distcc/hosts_new" ] && cat $BASEDIR/distcc/hosts_new | \
		distcc_test_hosts > $BASEDIR/distcc/hosts
}

distcc_test_hosts() {
	while read i; do
		if [ "${i}" = "localhost" ] || [ "${i:0:2}" = "--" ]; then
			echo ${i}
			continue
		fi

		i=${i%,lzo}
		host=$(awk -F: '{ print $1 }' <<<${i})
		jobs=${i##*/}
		port=$(awk -F: '{ print $2 }' <<<${i} | awk -F/ '{ print $1 }')
		ip=$($BASEDIR/tools/resolver $host)

		if ping -c3 -w5 ${ip} &>/dev/null; then
			if [ -n "$(which netcat)" ]; then
				if (echo | netcat -w 5 ${ip} ${port} 2>/dev/null); then
					echo "${ip}:${port}/${jobs},lzo # ${host}"
				else
					echo "# Host $host ($ip) is reachable but distcc does not respond."
				fi
				continue
			fi
			echo "${ip}:${port}/${jobs},lzo # ${host}"
		else
			echo "# Host $host ($ip) is not reachable."
		fi
	done
}

distcc_reload() {
	local NOW=$(date "+%s")
	[ -z "$DISTCC_RELOAD_TIMESTAMP" ] && DISTCC_RELOAD_TIMESTAMP=$NOW

	# Exit if last reload is less than 5 minutes ago
	if [ $(( $DISTCC_RELOAD_TIMESTAMP + 300 )) -ge $NOW ]; then
		return 0
	fi

	logger --distcc "[INFO] Reloading distcc..."
	distcc_get_hosts
	DISTCC_RELOAD_TIMESTAMP=$NOW
}

if [ "$(basename $0)" == "make-compilers" ]; then
	# Exit, when distccd is already running
	pidof distccd &>/dev/null && exit

	# Run distccd
	DISTCCD_PATH=$TOOLS_DIR/bin \
		$TOOLS_DIR/usr/bin/distccd --daemon --allow 0.0.0.0/0 \
		--user nobody --nice 10 --jobs $DISTCC_JOBS --port $DISTCC_PORT \
		--log-file $LOGFILE --stats --job-lifetime 600 \
		--stats-port $(( $DISTCC_PORT + 1 )) &>/dev/null

	# When $TOOLS_DIR is not available (esp. gcc) --> exit
	while pidof distccd >/dev/null && [ -x $TOOLS_DIR/bin/gcc ]; do
		sleep 10
	done

	killall distccd &>/dev/null
fi
