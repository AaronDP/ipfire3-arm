#!/bin/bash

LOGFILE=${BASEDIR}/naoki.log

function exithandler() {
	local mount
	local mounts

	log DEBUG "Unmounting everything in ${BUILD_DIR}..."
	while true; do
		mounts=$(mount | grep "${BUILD_DIR}")
		if [ -z "${mounts}" ]; then
			log DEBUG "  Everything is unmounted."
			break
		fi

		while read mount; do
			umount $(awk '{ print $3 }' <<<${mount})
		done <<<"${mounts}"
	done

	if [ ! -e "${BUILD_DIR}/.failed" ]; then
		rm -rf ${BUILD_DIR}
	fi

	log DEBUG "Shut down naoki instance with pid $$."
	log DEBUG "----------"
}
trap exithandler EXIT

function debug() {
	[ "${DEBUG}" = "1" ]
}

function force() {
	[ "${FORCE}" = "1" ]
}

function naoki_lock() {
	local lockfile="${BUILD_DIR}/.lock"

	case "${1}" in
		1)
			touch ${lockfile}
			;;
		0)
			rm -f ${lockfile}
			;;
		*)
			if [ -e "${lockfile}" ]; then
				return 0
			else
				return 1
			fi
			;;
	esac
}

function naoki_prepare() {
	local p=$(find_package ${1})
	shift

	msg "Preparing environment ${BUILD_DIR}..."

	# Download package's object files
	package_download ${p}
	[ $? -ne 0 ] && return 1

	mkdir -p ${BUILD_DIR}/usr/src

	if [ "${TOOLCHAIN}" = "1" ]; then
		## Creating /tools_xxx
		# if dir points to wrong direction, we will remove it.
		if [ "$(readlink ${TOOLS_DIR})" != "${TOOLS_DIR_REAL}" ]; then
			rm -f ${TOOLS_DIR}
		fi
		mkdir ${TOOLS_DIR_REAL} 2>/dev/null
		if [ ! -h "${TOOLS_DIR}" ]; then
			ln -fs ${TOOLS_DIR_REAL} ${TOOLS_DIR}
		fi

	else
		mkdir -p \
			${BUILD_DIR}/{boot,etc,root,tmp} \
			${BUILD_DIR}/{dev,proc,sys} \
			${BUILD_DIR}/{,usr/}{bin,lib,sbin} \
			${BUILD_DIR}/${BUILD_ROOT} \
			${BUILD_DIR}/${TOOLS_DIR}
	
		touch ${BUILD_DIR}/etc/{fstab,mtab}
	
		# Configure dns resolving
		cp -f /etc/resolv.conf /etc/hosts ${BUILD_DIR}/etc/

		grep ^root /etc/passwd > ${BUILD_DIR}/etc/passwd
		grep ^root /etc/group > ${BUILD_DIR}/etc/group

		local i
		for i in cache ccache pkgs src tools ${DIR_PACKAGES}; do
			if [ "${i:0:1}" != "/" ]; then
				i="${BASEDIR}/${i}"
			fi
			mkdir -p ${i} ${BUILD_DIR}/usr/src/${i##*/} 2>/dev/null
			mount --bind ${i} ${BUILD_DIR}/usr/src/${i##*/}
		done
		mount --bind ${TOOLS_DIR_REAL} ${BUILD_DIR}/${TOOLS_DIR}/
	
		# Mounting kernel fs
		## Maybe, it is not the best way to mount-bind the whole dev...
		for i in dev proc sys; do
			mount --bind /${i} ${BUILD_DIR}/${i}
		done

		# Extract needed packages
		local pkg_dependencies=$(package_dependencies_recursive ${p})
		msg "  Resolving recursive dependencies: ${pkg_dependencies-None}"
		local dep
		local missing
		for dep in ${pkg_dependencies}; do
			if ! package_is_built ${dep}; then
				missing="${missing} ${dep}"
			fi
		done
		if [ -n "${missing}" ]; then
			msg "Dependencies for ${p} are missing: ${missing}"
			return 4
		fi

		for dep in $(listsort ${pkg_dependencies} $(package_mandatory)); do
			package_decompress ${dep}
		done

		for i in /bin/bash /bin/echo /bin/pwd /bin/sh; do
			if [ -e "${BUILD_DIR}${i}" ]; then
				continue
			fi
			if [ ! -e "${TOOLS_DIR}${i}" ]; then
				log WARNING "Cannot create symlink ${i}: ${TOOLS_DIR}${i} - No such file or directory."
			fi
			log DEBUG "Creating symlink: ${BUILD_DIR}${i} --> ${TOOLS_DIR}${i}"
			ln -sf ${TOOLS_DIR}${i} ${BUILD_DIR}${i}
		done
	fi

	return 0
}

function naoki_cleanup() {
	local p=$(find_package ${1})

	log INFO "Cleaning up environment ${BUILD_DIR}..."

	if naoki_lock; then
		error "Cannot remove locked ${BUILD_DIR}..."
		return 1
	fi

	#rm -rf ${BUILD_DIR}
}

function naoki_cmd() {
	local package
	local chroot_cmd
	local cmd
	local with_chroot=1

	while [ $# -gt 0 ]; do
		case "${1}" in
			--without-chroot)
				with_chroot=0
				;;
			*)
				if [ -z "${package}" ]; then
					package=$(find_package ${1})
				else
					cmd="${cmd} ${1}"
				fi
				;;
		esac
		shift
	done
	cmd=${cmd:1}

	is_package ${package} || return 1

	log DEBUG "Running command \"${cmd}\" - chroot=${with_chroot}."
	
	local path="/sbin:/usr/sbin:/bin:/usr/bin"
	local toolchain_path="${TOOLS_DIR}/sbin:${TOOLS_DIR}/bin"
	if [ "${TOOLCHAIN}" = "1" ]; then
		path="${toolchain_path}:${path}"
	else
		path="${path}:${toolchain_path}"
	fi

	# ccache
	if [ -x "${BUILD_DIR}/usr/bin/ccache" ]; then
		path="/usr/ccache/bin:${path}"
	fi

	log DEBUG "  PATH : ${path}"
	
	local pkgroot=${DIR_PKGS}
	local ps1="\u:\w\$ "

	if [ "${with_chroot}" = "1" ]; then
		chroot_cmd="chroot ${BUILD_DIR}"
		pkgroot="/usr/src/pkgs"
		ps1="${CLR_NORM_RED}chroot${NORMAL}: \w\$ "

		touch ${BUILD_DIR}/.chroot
	fi

	local ret
	PATH=${path} \
	${chroot_cmd} \
		env -i \
			HOME="/root" \
			TERM="${TERM}" \
			PS1="${ps1}" \
			PATH="${path}" \
			\
			DISTRO_NAME="${DISTRO_NAME}" \
			DISTRO_SNAME="${DISTRO_SNAME}" \
			DISTRO_VERSION="${DISTRO_VERSION}" \
			DISTRO_EPOCH="${DISTRO_EPOCH}" \
			DISTRO_SLOGAN="${DISTRO_SLOGAN}" \
			\
			BASEDIR="${BASEDIR}" \
			ROOT=$([ "${TOOLCHAIN}" = "1" ] && \
				echo "${BUILD_DIR}") \
			CHROOT="${with_chroot}" \
			TOOLS_DIR="${TOOLS_DIR}" \
			TOOLCHAIN="${TOOLCHAIN}" \
			BUILDROOT="${BUILD_ROOT}" \
			PKGROOT="${pkgroot}" \
			\
			CFLAGS="${CFLAGS}" \
			CXXFLAGS="${CXXFLAGS}" \
			TARGET="${TARGET}" \
			TARGET_MACHINE="${MACHINE}" \
			PARALLELISMFLAGS="${PARALLELISMFLAGS}" \
			\
			CCACHE_DIR=$([ "${TOOLCHAIN}" = "1" ] && \
				echo "${BASEDIR}/ccache" || \
				echo "/usr/src/ccache") \
			\
			${cmd}

	ret=$?
	log DEBUG "  Exit code: ${ret}"

	return ${ret}
}

function naoki_make() {
	local p=${1}
	shift

	local cmd="make --no-print-directory -C"
	if [ "${CHROOT}" = "0" ] || [ "${TOOLCHAIN}" = "1" ]; then
		cmd="${cmd} ${DIR_PKGS}/${p}"
	else
		cmd="${cmd} /usr/src/pkgs/${p}"
	fi
	cmd="${cmd} -f ${p##*/}.nm"

	naoki_cmd ${p} "${cmd}" $@
	return ${PIPESTATUS[0]}
}

function naoki_build() {
	local p=$(find_package ${1})
	shift

	local ret
	msg "Going on to build package \"${p}\"."

	naoki_prepare ${p} $@
	ret=$?

	if [  "${ret}" != "0" ]; then
		error "Prepare command failed."
		exit ${ret}
	fi

	naoki_make ${p} package $@
	ret=$?

	if [  "${ret}" != "0" ]; then
		error "Package build failed."
		touch ${BUILD_DIR}/.failed
		exit ${ret}
	fi
}

function naoki_build_tree() {
	local packages
	local p

	package_tree $@ | \
		while read packages; do
			for p in ${packages}; do
				naoki_build ${p}
			done
		done
}

function naoki_shell() {
	local p=$(find_package ${1})
	shift

	naoki_prepare ${p}
	naoki_make ${p} shell

	# A little help message
	echo
	echo -e " ${CLR_NORM_RED}Chroot environment${NORMAL}"
	echo
	echo    "  This is starting a chrooted environment where you can natively"
	echo    "  access the build system. When you leave the shell all files will"
	echo    "  be lost."
	echo
	echo    "  Source of ${PKG_NAME} is extracted to /usr/src."
	echo
	echo -e "  ${BOLD}Exit with Ctrl+D.${NORMAL}"
	echo

	naoki_cmd ${p} "bash --login"
	local ret=$?

	echo
	echo    "Exit code: ${ret}"
	echo
}

function naoki_toolchain() {
	TOOLCHAIN=1

	local p=$(find_package ${1})
	shift

	naoki_build ${p} --without-chroot $@
}
