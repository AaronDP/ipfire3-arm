#!/bin/bash

function listmatch() {
	local arg=${1}
	shift

	grep -q "<${arg}>" <<<$@
}

function listremove() {
	local arg=${1}
	shift

	local value
	for value in $@; do
		if [ "${arg}" != "${value}" ]; then
			echo "${value}"
		fi
	done | tr "\n" " "
}

function listsort() {
	local value
	for value in $@; do
		echo "${value}"
	done | sort -u | tr "\n" " "
}

function is_package() {
	local package=$(find_package ${1})

	if [ -e "${DIR_PKGS}/${package}/${package##*/}.nm" ]; then
		return 0
	else
		log ERROR "Package ${package} is not known."
		return 1
	fi
}

function find_package() {
	local package=${1}
	local i

	#log DEBUG "Searching for package \"${package}\"."

	if [ -e "${DIR_PKGS}/${package}" ]; then
		echo "${package}"
		return 0
	fi

	for i in $(package_list); do
		if [ "${i##*/}" = "${package}" ]; then
			echo "${i}"
			return 0
		fi
	done
	return 1
}

function find_packages() {
	local p
	for p in $@; do
		find_package ${p}
	done | tr "\n" " "
}

function package_repos() {
	local repo
	
	for repo in ${DIR_PKGS}/*; do
		if [ ! -d "${repo}" ]; then
			continue
		fi
		
		if [ "${TOOLCHAIN}" = "1" ]; then
			if [ "${repo##*/}" != "toolchain" ]; then
				continue
			fi
		else
			if [ "${repo##*/}" = "toolchain" ]; then
				continue
			fi
		fi
		echo "${repo##*/}"
	done
}

## Needs to be cached...
#  Causes massive speed impact
function __package_list() {
	local package
	local repo
	
	for repo in $(package_repos); do
		for package in ${DIR_PKGS}/${repo}/*; do
			if [ ! -d "${package}" ]; then
				continue
			fi

			package=${package#${DIR_PKGS}/}

			# Skip if package does not fullfill our criteria
			is_package ${package} || continue

			echo "${package}"
		done
	done
}

function package_list() {
	if [ -z "${__PACKAGE_LIST}" ]; then
		log CACHE "Building packages_list."
		export __PACKAGE_LIST=$(__package_list)
	fi

	echo "${__PACKAGE_LIST}"
}

function package_profile() {
	if [ "${1}" = "--wiki" ]; then
		echo "TODO: WIKI OUTPUT"
	else
		# XXX to be formatted
		local package_name=$(find_package ${1})
		printf  "# ${BOLD}%-12s${NORMAL}: ${CLR_BOLD_GRN}%s${NORMAL}\n" "Name" "${package_name}"
		printf  "# ${BOLD}%-12s${NORMAL}: %s\n" "Version" "$(package_version ${package_name})"
		printf  "# ${BOLD}%-12s${NORMAL}: %s\n" "Release" "$(package_release ${package_name})"
		printf  "# ${BOLD}%-12s${NORMAL}: %s\n" "Group" "$(package_group ${package_name})"
		echo    "#"
		format $(package_summary ${package_name})
		echo    "#"
		echo -e "# ${BOLD}Description${NORMAL} :"
		format $(package_description ${package_name})
		echo    "#"
		printf  "# ${BOLD}%-12s${NORMAL}: %s\n" "Maintainer" "$(package_maintainer ${package_name})"
		printf  "# ${BOLD}%-12s${NORMAL}: %s\n" "License" "$(package_license ${package_name})"
		echo    "#"
	fi
}

function package_info() {
	local p=$(find_package ${1})

	log DEBUG "Fetching package information from ${DIR_PKGS}/${p}..."
	
	echo "gothere: ${p}" > .test

	is_package ${p} || return 1

	if [ "${NAOKI_INCLUDE}" = "1" ]; then
		CHROOT=0 naoki_make ${p} --without-chroot info | grep -v "^make:"
	else
		${NAOKI} info ${p}
	fi
}

function package_cache_update() {
	local p=$(find_package ${1})

	fingerprint=$(__package_cache_get "${p}" "FINGERPRINT")
	if [ -n "${fingerprint}" ]; then
		if [ "$(package_fingerprint ${p})" = "${fingerprint}" ]; then
			return
		fi
	fi

	log DEBUG "Cache information of ${p} needs update."

	local line object data

	cat ${PACKAGES_CACHE} | grep -v "^${1}.${2}" > ${PACKAGES_CACHE}

	package_info ${p} | \
		while read line; do
			object=${line%%=*}
			data=${line##*=}

			__package_cache_set "${p}" "${object}" "$(tr -d '"' <<<${data})"
		done
	__package_cache_set "${p}" "FINGERPRINT" "$(package_fingerprint ${p})"
}

function __package_cache_set() {
	echo -e "${1}\t${2}\t${3}" >> ${PACKAGES_CACHE}
}

function __package_cache_get() {
	local output=$(grep -e "^${1}.${2}" ${PACKAGES_CACHE})
	echo "${output:$(( ${#1} + ${#2} + 2))}"
}

function package_get() {
	local p=$(find_package ${1})
	local object=${2}

	# Check if cache data is up2date
	package_cache_update ${p}

	__package_cache_get "${p}" "${object}"
}


function package_name() {
	package_get ${1} PKG_NAME
}

function package_version() {
	package_get ${1} PKG_VER
}

function package_release() {
	package_get ${1} PKG_REL
}

function package_description() {
	package_get ${1} PKG_DESCRIPTION
}

function package_summary() {
	package_get ${1} PKG_SUMMARY
}

function __deps() {
	local info=${1}
	local recursive=${2}
	local package=$(find_package ${3})

	local deps=$(find_packages $(package_get ${package} ${info}))

	if [ "${recursive}" = "1" ]; then
		local dep
		local size
		while true; do
			size=${#deps}

			for dep in ${deps}; do
				deps="${deps} $(package_get ${dep} ${info}) $(package_runtime_dependencies ${dep})"
			done

			deps=$(find_packages $(listsort ${deps}))

			[ ${#deps} -eq ${size} ] && break
		done
	fi
	echo $(find_packages $(listsort ${deps}))
}

function package_runtime_dependencies() {
	__deps PKG_DEPENDENCIES 0 $@
}

function package_runtime_dependencies_recursive() {
	__deps PKG_DEPENDENCIES 1 $@
}

function package_build_dependencies() {
	__deps PKG_BUILD_DEPENDENCIES 0 $@
}

function package_build_dependencies_recursive() {
	__deps PKG_BUILD_DEPENDENCIES 1 $@
}

function package_toolchain_dependencies() {
	__deps PKG_TOOLCHAIN_DEPENDENCIES 0 $@
}

function package_toolchain_dependencies_recursive() {
	__deps PKG_TOOLCHAIN_DEPENDENCIES 1 $@
}

function package_dependencies() {
	if [ "${TOOLCHAIN}" = "1" ]; then
		package_toolchain_dependencies $@
	else
		package_runtime_dependencies $@
		package_build_dependencies $@
	fi
}

function package_dependencies_recursive() {
	if [ "${TOOLCHAIN}" = "1" ]; then
		package_toolchain_dependencies_recursive $@
	else
		listsort $(package_runtime_dependencies_recursive $@) \
			$(package_build_dependencies_recursive $@)
	fi
}

function package_packages() {
	package_get ${1} PKG_PACKAGES_FILES
}

function package_maintainer() {
	package_get ${1} PKG_MAINTAINER
}

function package_group() {
	package_get ${1} PKG_GROUP
}

function package_license() {
	package_get ${1} PKG_LICENSE
}

function package_objects() {
	package_get ${1} PKG_OBJECTS
}

function package_is_built() {
	local package=$(find_package ${1})

	local file
	for file in $(package_packages ${package}); do
		if [ ! -e "${DIR_PACKAGES}/${file}" ]; then
			return 1
		fi
	done
	return 0
}

function package_sort() {
	local pkg
	for pkg in $@; do
		echo "${pkg}"
	done | sort -u | tr '\n' ' '
}

function __random() {
	local date=$(date "+%N")
	while [ "${date:0:1}" = "0" ]; do
		if [ "${#date}" = "0" ]; then
			echo "0"
			return
		fi
		date=${date:1}
	done
	echo $(( ${date} % 2 ))
}

function package_random() {
	local package
	local ret
	
	for package in $@; do
		if [ "$(__random)" = "0" ]; then
			ret="${ret} ${package}"
		else
			ret="${package} ${ret}"
		fi
	done
	if [ "$(__random)" = "0" ]; then
		ret=$(package_random ${ret})
	fi
	echo ${ret}
}

function package_tree() {
	local package
	local package2
	local packages
	local deps
	
	log INFO "Making package tree..."

	ret[0]=$@
	local i=0
	while true; do
		packages=${ret[i]}
		deps=
		for package in ${packages}; do
			deps="${deps} $(package_dependencies ${package})"
		done
		deps=$(package_sort ${deps})
		if [ -n "${deps}" ]; then
			ret[$(( ${i} + 1 ))]=${deps}
		else
			break
		fi
		i=$(( ${i} + 1 ))
	done

	local drop
	local j
	i=0
	while [ ${i} -lt ${#ret[@]} ]; do
		for package in ${ret[i]}; do
			drop=0
			j=$(( ${#ret[@]} - 1 ))
			while [ ${j} -gt ${i} ]; do
				for package2 in ${ret[j]}; do
					if [ "${package}" == "${package2}" ]; then
						drop=1
						break
					fi
				done
				if [ "${drop}" = "1" ]; then
					break
				fi
				j=$(( ${j} - 1 ))
			done
			if [ "${drop}" = "1" ]; then
				packages=
				for package2 in ${ret[i]}; do
					if [ "${package}" != "${package2}" ]; then
						packages="${packages} ${package2}"
					fi
				done
				ret[${i}]=$(package_sort ${packages})
			fi
		done
		i=$(( ${i} + 1 ))
	done

	i=$(( ${#ret[@]} - 1 ))
	while [ ${i} -ge 0 ]; do
		log INFO "  ${i}: ${ret[i]}"
		echo "$(package_random ${ret[i]})"
		i=$(( ${i} - 1 ))
	done
}

function require_toolchain() {
	local package
	for package in ${PACKAGES_TO_EXTRACT}; do
		package=$(find_package ${package})
		if ! package_is_built ${package}; then
			return 0
		fi
	done
	return 1
}

function package_id() {
	local p=$(find_package ${1})
	local hash=$(sha1sum <<<${p})

	echo ${hash:0:6}
}

function package_decompress() {
	local file
	local pkg
	for pkg in $@; do
		if ! package_is_built ${pkg}; then
			log WARNING "Cannot extract package \"${pkg}\". It has not been built, yet."
			continue
		fi
		for file in $(package_packages ${pkg}); do
			PATH=${TOOLS_DIR}/sbin:${TOOLS_DIR}/bin:${PATH} \
				${BASEDIR}/src/pakfire/decompressor --root=${BUILD_DIR} \
					${DIR_PACKAGES}/${file}
		done
	done
}

function package_mandatory() {
	local package
	local packages=$(find_packages ${PACKAGES_MANDATORY})

	for package in ${packages}; do
		if ! package_is_built ${package}; then
			log DEBUG "Mandatory package \"${package}\" has not been built, yet."
			continue
		fi
		echo "${package} $(package_runtime_dependencies_recursive ${package})"
	done #| tr " " "\n" | sort -u
}

function package_download() {
	local package=$(find_package ${1})

	local object
	local to_download
	for object in $(package_objects ${package}); do
		if [ -e "${DIR_TARBALLS}/${object}" ] || \
			[ -e "${DIR_PATCHES}/${object}" ]; then
			continue
		fi
		to_download="${to_download} ${object}"
	done
	if [ -n "${to_download}" ]; then
		log DEBUG "Going to get file(s): ${to_download}"
		${DOWNLOADER} --tarballs="${DIR_TARBALLS}" \
			--patches="${DIR_PATCHES}" ${to_download}
		if [ "$?" != "0" ]; then
			return 1
		fi
	fi
}

function package_fingerprint() {
	local p=$(find_package ${1})
	# time of modification in seconds since Epoch
	stat --printf="%Y" ${DIR_PKGS}/${p}/${p##*/}.nm
}
