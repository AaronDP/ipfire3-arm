#!/bin/bash

function listmatch() {
	local arg=${1}
	shift
	
	local value
	for value in $@; do
		if [ "${arg}" == "${value}" ]; then
			return 0
		fi
	done
	return 1
}

function listremove() {
	local arg=${1}
	shift

	local value
	for value in $@; do
		if [ "${arg}" != "${value}" ]; then
			echo "${value}"
		fi
	done | tr "\n" " "
}

function is_package() {
	local package=$(find_package ${1})

	if [ -e "${DIR_PKGS}/${package}/${package##*/}.nm" ]; then
		return 0
	else
		log ERROR "Package ${package} is not known."
		return 1
	fi
}

function find_package() {
	local package=${1}
	#log DEBUG "Searching for package \"${package}\"."

	if [ -e "${DIR_PKGS}/${package}" ]; then
		echo "${package}"
		return 0
	fi

	local i
	for i in $(package_list); do
		if [ "${i##*/}" = "${package}" ]; then
			echo "${i}"
			return 0
		fi
	done
	return 1
}

function package_repos() {
	local repo
	
	for repo in ${DIR_PKGS}/*; do
		if [ ! -d "${repo}" ]; then
			continue
		fi
		
		if [ "${TOOLCHAIN}" = "1" ]; then
			if [ "${repo##*/}" != "toolchain" ]; then
				continue
			fi
		else
			if [ "${repo##*/}" = "toolchain" ]; then
				continue
			fi
		fi
		echo "${repo##*/}"
	done
}

function package_list() {
	local package
	local repo
	
	for repo in $(package_repos); do
		for package in ${DIR_PKGS}/${repo}/*; do
			if [ ! -d "${package}" ]; then
				continue
			fi

			package=${package#${DIR_PKGS}/}

			# Skip if package does not fullfill our criteria
			is_package ${package} || continue

			echo "${package}"
		done
	done
}

function package_profile() {
	if [ "${1}" = "--wiki" ]; then
		echo "TODO: WIKI OUTPUT"
	else
		# XXX to be formatted
		local package_name=$(find_package ${1})
		printf  "# ${BOLD}%-12s${NORMAL}: ${CLR_BOLD_GRN}%s${NORMAL}\n" "Name" "${package_name}"
		printf  "# ${BOLD}%-12s${NORMAL}: %s\n" "Version" "$(package_version ${package_name})"
		printf  "# ${BOLD}%-12s${NORMAL}: %s\n" "Release" "$(package_release ${package_name})"
		printf  "# ${BOLD}%-12s${NORMAL}: %s\n" "Group" "$(package_group ${package_name})"
		echo    "#"
		format $(package_summary ${package_name})
		echo    "#"
		echo -e "# ${BOLD}Description${NORMAL} :"
		format $(package_description ${package_name})
		echo    "#"
		printf  "# ${BOLD}%-12s${NORMAL}: %s\n" "Maintainer" "$(package_maintainer ${package_name})"
		printf  "# ${BOLD}%-12s${NORMAL}: %s\n" "License" "$(package_license ${package_name})"
		echo    "#"
	fi
}

function package_info() {
	local p=$(find_package ${1})

	log DEBUG "Fetching package information from ${DIR_PKGS}/${p}..."
	
	echo "gothere: ${p}" > .test

	is_package ${p} || return 1

	if [ "${NAOKI_INCLUDE}" = "1" ]; then
		CHROOT=0 naoki_make ${p} --without-chroot info | grep -v "^make:"
	else
		${NAOKI} info ${p}
	fi
}

function package_get() {
	local package=$(find_package ${1})
	local item=${2}

	package_info ${package} | \
		grep "^${item}" | \
		awk -F= '{ print $NF }' | \
		tr -d '"'
}

function package_name() {
	package_get ${1} PKG_NAME
}

function package_version() {
	package_get ${1} PKG_VER
}

function package_release() {
	package_get ${1} PKG_REL
}

function package_description() {
	package_get ${1} PKG_DESCRIPTION
}

function package_summary() {
	package_get ${1} PKG_SUMMARY
}

function package_runtime_dependencies() {
	local recursive=0
	if [ "${1}" = "--recursive" ]; then
		recursive=1
		shift
	fi

	local ret
	local package
	for package in $(package_get ${1} PKG_DEPENDENCIES); do
		package=$(find_package ${package})
		ret="${ret} ${package}"
		log DEBUG "  Got runtime dep: ${package}"
	done

	if [ "${recursive}" = "1" ]; then
		package_recursive_dependencies package_runtime_dependencies ${ret}
	else
		echo ${ret}
	fi
}

function package_build_dependencies() {
	local package
	for package in $(package_get ${1} PKG_BUILD_DEPENDENCIES); do
		package=$(find_package ${package})
		echo "${package}"
		log DEBUG "  Got build dep: ${package}"
	done
}

function package_toolchain_dependencies() {
	local recursive=0
	if [ "${1}" = "--recursive" ]; then
		recursive=1
		shift
	fi

	local ret
	local package
	for package in $(package_get ${1} PKG_TOOLCHAIN_DEPS); do
		package=$(find_package ${package})
		ret="${ret} ${package}"
		log DEBUG "  Got toolchain dep: ${package}"
	done

	if [ "${recursive}" = "1" ]; then
		package_recursive_dependencies package_toolchain_dependencies ${ret}
	else
		echo ${ret}
	fi
}

function package_dependencies() {
	if [ "${TOOLCHAIN}" = "1" ]; then
		package_toolchain_dependencies $@
	else
		package_runtime_dependencies $@
		package_build_dependencies $@
	fi
}

function package_recursive_dependencies() {
	local func=${1}
	shift

	local to_check=$@
	local checked
	while true; do
		if [ -z "${to_check}" ]; then
			break
		fi

		local i
		for i in ${to_check}; do
			if ! listmatch ${i} ${to_check}; then
				to_check="${to_check} $(${func} ${i})"
			fi
			checked="${checked} ${i}"
			to_check="$(listremove ${i} ${to_check})"
		done
	done
	echo ${checked}
}

function package_dependencies_for_build() {
	local p=$(find_package ${1})

	local i
	local ret="$(package_dependencies ${p})"
	for i in ${ret}; do
		ret="${ret} $(package_runtime_dependencies --recursive ${i})"
	done

	echo ${ret}
}

function package_packages() {
	package_get ${1} PKG_PACKAGES_FILES
}

function package_maintainer() {
	package_get ${1} PKG_MAINTAINER
}

function package_group() {
	package_get ${1} PKG_GROUP
}

function package_license() {
	package_get ${1} PKG_LICENSE
}

function package_objects() {
	package_get ${1} PKG_OBJECTS
}

#function package_extract_dependencies() {
#	local package=$(find_package ${1})
#	local to_extract="${PACKAGES_TO_EXTRACT}"
#	
#	local dep
#	for dep in $(dependencies_resolve ${PACKAGES_TO_EXTRACT} ${package}); do
#		echo ${dep}
#	done
#}

function package_is_built() {
	local package=$(find_package ${1})

	local file
	for file in $(package_packages ${package}); do
		if [ ! -e "${DIR_PACKAGES}/${file}" ]; then
			return 1
		fi
	done
	return 0
}

#function dependencies_resolve() {
#	local dependencies
#	local package
#	local ret
#
#	for package in $@; do
#		log DEBUG "Resolving dependencies for ${package}..."
#
#		dependencies=$(package_dependencies ${package})
#
#		if [ -n "${dependencies}" ]; then
#			log DEBUG "  Got: ${dependencies}"
#
#			for dep in ${dependencies}; do
#				if ! listmatch ${dep} ${ret}; then
#					ret="${ret} ${dep} $(dependencies_resolve ${dep})"
#				fi
#			done
#		fi
#	done
#
#	# Sort and unique the package list
#	for package in ${ret}; do
#		echo "${package}"
#	done | sort -u
#}

function package_sort() {
	local pkg
	for pkg in $@; do
		echo "${pkg}"
	done | sort -u | tr '\n' ' '
}

function __random() {
	local date=$(date "+%N")
	while [ "${date:0:1}" = "0" ]; do
		if [ "${#date}" = "0" ]; then
			echo "0"
			return
		fi
		date=${date:1}
	done
	echo $(( ${date} % 2 ))
}

function package_random() {
	local package
	local ret
	
	for package in $@; do
		if [ "$(__random)" = "0" ]; then
			ret="${ret} ${package}"
		else
			ret="${package} ${ret}"
		fi
	done
	if [ "$(__random)" = "0" ]; then
		ret=$(package_random ${ret})
	fi
	echo ${ret}
}

function package_tree() {
	local package
	local package2
	local packages
	local deps
	
	log INFO "Making package tree..."

	ret[0]=$@
	local i=0
	while true; do
		packages=${ret[i]}
		deps=
		for package in ${packages}; do
			deps="${deps} $(package_dependencies ${package})"
		done
		deps=$(package_sort ${deps})
		if [ -n "${deps}" ]; then
			ret[$(( ${i} + 1 ))]=${deps}
		else
			break
		fi
		i=$(( ${i} + 1 ))
	done

	local drop
	local j
	i=0
	while [ ${i} -lt ${#ret[@]} ]; do
		for package in ${ret[i]}; do
			drop=0
			j=$(( ${#ret[@]} - 1 ))
			while [ ${j} -gt ${i} ]; do
				for package2 in ${ret[j]}; do
					if [ "${package}" == "${package2}" ]; then
						drop=1
						break
					fi
				done
				if [ "${drop}" = "1" ]; then
					break
				fi
				j=$(( ${j} - 1 ))
			done
			if [ "${drop}" = "1" ]; then
				packages=
				for package2 in ${ret[i]}; do
					if [ "${package}" != "${package2}" ]; then
						packages="${packages} ${package2}"
					fi
				done
				ret[${i}]=$(package_sort ${packages})
			fi
		done
		i=$(( ${i} + 1 ))
	done

	i=$(( ${#ret[@]} - 1 ))
	while [ ${i} -ge 0 ]; do
		log INFO "  ${i}: ${ret[i]}"
		echo "$(package_random ${ret[i]})"
		i=$(( ${i} - 1 ))
	done
}

function require_toolchain() {
	local package
	for package in ${PACKAGES_TO_EXTRACT}; do
		package=$(find_package ${package})
		if ! package_is_built ${package}; then
			return 0
		fi
	done
	return 1
}

function package_id() {
	local p=$(find_package ${1})
	local hash=$(sha1sum <<<${p})

	echo ${hash:0:6}
}

function package_decompress() {
	local file
	local pkg
	for pkg in $@; do
		for file in $(package_packages ${pkg}); do
			PATH=${TOOLS_DIR}/sbin:${TOOLS_DIR}/bin:${PATH} \
				${BASEDIR}/src/pakfire/decompressor --root=${BUILD_DIR} \
					${DIR_PACKAGES}/${file}
		done
	done
}
