#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2008  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################
###############################################################################
#
# Beautifying variables & presentation & input output interface
#
###############################################################################

## Screen Dimentions
# Find current screen size
if [ -z "${COLUMNS}" ]; then
	COLUMNS=$(stty size 2>/dev/null)
	COLUMNS=${COLUMNS##* }
fi

# When using remote connections, such as a serial port, stty size returns 0
if [ "${COLUMNS}" = "0" ]; then
	COLUMNS=80
fi

## Measurements for positioning result messages
RESULT_WIDTH=4
TIME_WIDTH=8
OPT_WIDTH=7
VER_WIDTH=10
RESULT_COL=$((${COLUMNS} - $RESULT_WIDTH - 4))
TIME_COL=$((${RESULT_COL} - $TIME_WIDTH - 5))
VER_COL=$((${TIME_COL} - $VER_WIDTH - 5))
OPT_COL=$((${VER_COL} - $OPT_WIDTH - 5))

## Set Cursur Position Commands, used via echo -e
SET_RESULT_COL="\\033[${RESULT_COL}G"
SET_TIME_COL="\\033[${TIME_COL}G"
SET_VER_COL="\\033[${VER_COL}G"
SET_OPT_COL="\\033[${OPT_COL}G"

# Normal colors
CLR_NORM_BLK="\\033[0;30m"    # black
CLR_NORM_RED="\\033[0;31m"    # red
CLR_NORM_GRN="\\033[0;32m"    # green
CLR_NORM_YEL="\\033[0;33m"    # yellow
CLR_NORM_BLU="\\033[0;34m"    # blue
CLR_NORM_MAG="\\033[0;35m"    # magenta
CLR_NORM_CYN="\\033[0;36m"    # cyan
CLR_NORM_WHT="\\033[0;37m"    # white
CLR_NORM_GRY="\\033[0;39m"    # grey

# Emphased colors
CLR_BOLD_BLK="\\033[1;30m"    # black
CLR_BOLD_RED="\\033[1;31m"    # red
CLR_BOLD_GRN="\\033[1;32m"    # green
CLR_BOLD_YEL="\\033[1;33m"    # yellow
CLR_BOLD_BLU="\\033[1;34m"    # blue
CLR_BOLD_MAG="\\033[1;35m"    # magenta
CLR_BOLD_CYN="\\033[1;36m"    # cyan
CLR_BOLD_WHT="\\033[1;37m"    # white
CLR_BOLD_GRY="\\033[1;39m"    # grey

# Background colors
CLR_BACK_BLK="\\033[40m"      # black
CLR_BACK_RED="\\033[41m"      # red
CLR_BACK_GRN="\\033[42m"      # green
CLR_BACK_YEL="\\033[43m"      # yellow
CLR_BACK_BLU="\\033[44m"      # blue
CLR_BACK_MAG="\\033[45m"      # magenta
CLR_BACK_CYN="\\033[46m"      # cyan
CLR_BACK_WHT="\\033[47m"      # white

# Action colors
BOLD=$CLR_BOLD_GRY
DONE=$CLR_BOLD_GRN
SKIP=$CLR_BOLD_BLU
WARN=$CLR_BOLD_MAG
FAIL=$CLR_BOLD_RED
NORMAL=$CLR_NORM_GRY

# Color hooks
BRACKET_L="${CLR_BOLD_BLU}[${NORMAL}"
BRACKET_R="${CLR_BOLD_BLU}]${NORMAL}"

position_cursor() {
	# ARG1=starting position on screen
	# ARG2=string to be printed
	# ARG3=offset, negative for left movement, positive for right movement, relative to ARG1
	# For example if your starting position is column 50 and you want to print Hello three columns to the right
	# of your starting position, your call will look like this:
	# position_cursor 50 "Hello" 3 (you'll get the string Hello at position 53 (= 50 + 3)
	# If on the other hand you want your string "Hello" to end three columns to the left of position 50,
	# your call will look like this:
	# position_cursor 50 "Hello" -3 (you'll get the string Hello at position 42 (= 50 - 5 -3)
	# If you want to start printing at the exact starting location, use offset 0

	START=$1
	STRING=$2
	OFFSET=$3

	STRING_LENGTH=${#STRING}

	if [ ${OFFSET} -lt 0 ]; then
		COL=$((${START} + ${OFFSET} - ${STRING_LENGTH}))
	else
		COL=$((${START} + ${OFFSET}))
	fi

	SET_COL="\\033[${COL}G"

	echo $SET_COL
} # End of position_cursor()

beautify() {
	# Commands: build_stage, make_pkg, message, result
	case "$1" in
		message)
			MESSAGE="$3"
			echo -ne "${BOLD}${MESSAGE}${NORMAL}${SET_RESULT_COL}${BRACKET_L}"
			case "$2" in
				DONE) echo -ne " ${DONE}DONE${NORMAL} ";;
				WARN) echo -ne " ${WARN}WARN${NORMAL} ";;
				FAIL) echo -ne " ${FAIL}FAIL${NORMAL} ";;
				SKIP) echo -ne " ${SKIP}SKIP${NORMAL} ";;
				ON|ENAB*)  echo -ne " ${DONE}ENAB${NORMAL} ";;
				OFF|DISA*) echo -ne " ${FAIL}DISA${NORMAL} ";;
			esac
			echo -ne "${BRACKET_R}\n"
			;;
		build_stage)
			MESSAGE=$2
			echo -ne "${BOLD}*** ${MESSAGE}${SET_OPT_COL}  options${SET_VER_COL}     version "
			echo -ne "${SET_TIME_COL}    time    ${SET_RESULT_COL} status${NORMAL}\n"
			;;
		package)
			local PKG_NAME=$2
			local PKG_VER=$(shrink_string $VER_WIDTH $3)
			local OPTIONS=$4

			SET_VER_COL_REAL=`position_cursor $TIME_COL "$PKG_VER" -3`

			echo -ne "${PKG_NAME}"
			if ! [ "$OPTIONS" == "" ]; then
				echo -ne "${SET_OPT_COL}${BRACKET_L} ${BOLD}${OPTIONS}${NORMAL} ${BRACKET_R}"
			fi

			if [ -z "${PKG_VER}" ]; then
				echo -ne "${SET_RESULT_COL}"
			else
				echo -ne "${SET_VER_COL}${BRACKET_L} ${BOLD}${SET_VER_COL_REAL}${PKG_VER}"
				echo -ne "${NORMAL} ${BRACKET_R}${SET_RESULT_COL}"
			fi
			;;
		result)
			RESULT=$2

			if [ ! $3 ]; then
				PKG_TIME=0
			else
				PKG_TIME=$3
			fi

			# If time is lager than one minute display it like this: <minutes>:<seconds>, e.g. 1:16
			[ $PKG_TIME -ge 60 ] && PKG_TIME=$(printf "%d:%02d" $[ $PKG_TIME / 60 ] $[ $PKG_TIME % 60 ])

			SET_TIME_COL_REAL=`position_cursor $RESULT_COL $PKG_TIME -3`
			echo -ne "${SET_TIME_COL}${BRACKET_L} ${BOLD}${SET_TIME_COL_REAL}$PKG_TIME${NORMAL} ${BRACKET_R}"
			case "$RESULT" in
				DONE) echo -ne "${SET_RESULT_COL}${BRACKET_L} ${DONE}DONE${NORMAL} ${BRACKET_R}\n";;
				FAIL) echo -ne "${SET_RESULT_COL}${BRACKET_L} ${FAIL}FAIL${NORMAL} ${BRACKET_R}\n";;
				SKIP) echo -ne "${SET_RESULT_COL}${BRACKET_L} ${SKIP}SKIP${NORMAL} ${BRACKET_R}\n";;
			esac
			;;
	esac
} # End of beautify()

function shrink_string() {
	local LENGTH=$1
	shift
	local STRING=$@

	if [ ${#STRING} -gt $LENGTH ]; then
		# If a string is greater than $LENGTH, we keep the first 4 characters
		# and replace enough characters to fit the resulting string on the screen. We'll replace
		# the extra character with .. (two dots). That's why the "+ 2" in the formula below.
		# Example: if we have a 21-long string that we want to fit into a 10-long space,
		# we have to remove 11 characters.  But if we replace 11 characters with 2 characters, we'll
		# end up with a 12-character long string.  That's why we replace 12 characters with ..
		REMOVE=$(expr substr "$STRING" 4 $[ ${#STRING} - $LENGTH + 2 ])
		STRING=$(echo ${STRING/$REMOVE/..})
	fi

	echo "$STRING"
} # End of shrink_string()

dialogerror() {
	beautify message FAIL

	echo -ne "${FAIL}ERROR${NORMAL}: ${BOLD}$*${NORMAL}\n"
	[ -z "$LOGFILE" ] || \
	echo "       Check $LOGFILE for errors if applicable"
} # End of dialogerror()
