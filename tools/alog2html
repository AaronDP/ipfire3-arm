#!/usr/bin/python
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2008  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################
# Author: 08-2008 - Heiner Schmeling                                          #
###############################################################################

### define variables
HEADER='''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
       "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Beschreibung der Seite</title>
<style type="text/css"> 
* {
  font-size:14px;
  }

.black{color:#000000;}
.red{color:#ff0000;}
.green{color:#00ff00;}
.yellow{color:#ff0000;}
.blue{color:#0000ff;}
.magenta{color:#ff0000;}
.cyan{color:#ff0000;}
.white{color:#ffffff;}
.ul {text-decoration:underline}
.b {font-weight:bold}

.bggray {background-color:#eeeeee;}

.tal {text-align:left;}
.tar {text-align:right;}
.tac {text-align:center;}
</style>
</head>
<body>
<TABLE BORDER="0" cellspacing="0">
'''

FOOTER='''</TABLE>
</body>
</html>
'''

sESC='\x1b['
sBEL='\x07'
sSpace='\x20'
lineNr = 0																		# Counter for readed lines
hg_colStr=''																	# define variable for Backgroundcolor

### definition for lots of variable 'linelist'
##  linelist=[[pos,fgcolor,hgcolor,bold,text]]
# pos     = current Cursorposition
# fgcolor = Vordergrund Farbe
# hgcolor = Hintergrund Farbe
# bold    = ist Bold aktiv (0/1)
# text    = Text


print HEADER

### beginning
while 1:
	try:
		line = raw_input()														# read from standard device
		lineNr += 1																# increment linecounter
	except EOFError:
		break																	# break/exit is "End Of File"


	if len(line)>0 and line[-1]=='\x0d' :										# evtl. vorhandenen '/r' entfernen
		line=line[:-1]
	line=line.replace(sBEL,sSpace).strip()

	isBoldOn = 0																# is Bold active ?
	linelist = []																# define emty list

	new_String = ''
	new_line_split = []
	colStr = ""
	BoldOn=""
	pos = 0

	line_split = line.split(sESC)												# Split readed line with sESC separator
	cnt_line_split = len(line_split)											# len/count of line_split

### decode escape sequences
	for splitNr in range(0,cnt_line_split):

		lsStr = line_split[splitNr]												# string of array (line split string)

		num_cnt = 0																# count for numbers

		if splitNr == 0 :														# split nr 0 have not EscapeSequences
			new_String=line_split[0]
			if len(lsStr)>0:
				test_ = [pos,colStr,hg_colStr,BoldOn,lsStr]
				linelist.append(test_)
				pos +=len(lsStr)
		else:
			lsStr_len = len(lsStr)												# Ueberpruefung der Teilstring-Laenge
			if lsStr_len > 5 :
				lsStr_len = 5

			for x1 in range(0,lsStr_len):
				found=''
				zeichen=lsStr[x1]
				if zeichen == ";" :
					if num_cnt == 1 :
						if lsStr[x1-1] == '0' and isBoldOn == 1:
							isBoldOn = 0
							BoldOn=""
						elif lsStr[x1-1] == '1' and isBoldOn == 0:
							isBoldOn = 1
							BoldOn=" b"
						else:
							print 'ERROR: BOLD nicht 0 oder 1'
					else:
						print 'ERROR: >2 Zahlen in fuer BOLD'
					num_cnt = 0													# reset count for numbers
					continue
				elif zeichen.isdigit() :
					num_cnt += 1
					continue
				elif zeichen == 'J' :
					found='J'
					break
				elif zeichen == 'H' :
					found='H'
					break
				elif zeichen == 'G' :
					found='G'
					pos = int(lsStr[x1-num_cnt:x1])
					break
				elif zeichen == 'm' :
					found='m'
					color = lsStr[x1-1]
					if color == '0' :
						colStr='white'
					elif color == '1' :
						colStr='red'
					elif color == '2' :
						colStr='green'
					elif color == '3' :
						colStr='yellow'
					elif color == '4' :
						colStr='blue'
					elif color == '5' :
						colStr='magenta'
					elif color == '6' :
						colStr='cyan'
					elif color == '7' :
						colStr='black'
					elif color == '8' :
						colStr='888'
					elif color == '9' :
						colStr=''												# reset Color
					break

			if found <> '' :
				if colStr<>'' or BoldOn<>'' :
					new_String +='<span class="%s%s">%s</span>' % (colStr,BoldOn,lsStr[x1+1:])
				else:
					new_String +=lsStr[x1+1:]

			_lsStr=lsStr[x1+1:]
			if _lsStr<>'' :
				if not _lsStr.isspace() :
					test_ = [pos,colStr,hg_colStr,BoldOn,_lsStr]
					linelist.append(test_)
				pos +=len(_lsStr)
			new_line_split.append(_lsStr)

### begin table <tr>
	if lineNr % 2 != 0 :
		print '<tr class="bggray">'
	else :
		print '<tr>'

### first table entry 'linecounter'
	print '\t<td class="tar">%d: </td>' % (lineNr)

### other table entrys
	linelist_cnt=len(linelist)
	if linelist_cnt > 0 :

		cnt_bracket=0															# Count string '[' for Tab's
		for cnt in range(0,linelist_cnt): 
			cnt_bracket+=linelist[cnt][4].count('[')

		if linelist[0][4].count('*') == 3 and linelist_cnt == 5 :				# Find 3 x '*'
			for cnt in range(0,13):
				if cnt == 0 : print '\t<td class="b">%s</td>' % (linelist[0][4])
				elif cnt == 2 : print '\t<td class="tac b">%s</td>' % (linelist[1][4])
				elif cnt == 5 : print '\t<td class="tac b">%s</td>' % (linelist[2][4])
				elif cnt == 8 : print '\t<td class="tac b">%s</td>' % (linelist[3][4])
				elif cnt == 11 : print '\t<td class="tac b">%s</td>' % (linelist[4][4])
				else : print '\t<td></td>'
		else :
			cnt_tabs = linelist_cnt-(cnt_bracket*3)
			for cnt in range(0,cnt_tabs) :
				if cnt == 0 : 
					if linelist[cnt][1] or linelist[cnt][2] :
						print '\t<td class="'+linelist[cnt][1]+linelist[cnt][2]+'">',
					else :
						print '\t<td>',
				if linelist[cnt][3] :
					print '<b>'+linelist[cnt][4]+'</b>',
				else :
					print linelist[cnt][4],
			print '</td>'

			if linelist[0][0] == 0 : 
				start = 1
			else :
				start = 0
			for cnt in range(start, 13-cnt_bracket*3 ) :						# Fill empty tabs
				print '\t<td></td>'

			for cnt in range(cnt_tabs,linelist_cnt) :
				if linelist[cnt][1] or linelist[cnt][2] or linelist[cnt][3] :
					print '\t<td class="tar '+linelist[cnt][1]+linelist[cnt][2]+linelist[cnt][3]+'">',
				else :
					print '\t<td>',
				print linelist[cnt][4]+'</td>'

	else :
		for cnt in range(0, 13) :												# Fill empty tabs
			print '\t<td></td>'

### close table </tr>
	print '</tr>'

print FOOTER
