#!/usr/bin/python
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2008  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################
# Author: 08-2008 - Heiner Schmeling                                          #
###############################################################################

HEAD="""<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
       "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Beschreibung der Seite</title>
<style type="text/css"> 
* {
  font-size:14px;
  <--color:#000000;
  }

.black{color:#000000;}
.red{color:#ff0000;}
.green{color:#00ff00;}
.yellow{color:#ff0000;}
.blue{color:#0000ff;}
.magenta{color:#ff0000;}
.cyan{color:#ff0000;}
.white{color:#ffffff;}
.ul {text-decoration:underline}
.b {font-weight:bold}

.bggray {background-color:#eeeeee;}
.bggray2 {background-color:#cccccc;}

.tal {text-align:left;}
.tar {text-align:right;}
.tac {text-align:center;}
</style>
</head>
<body>
<TABLE BORDER="0" cellspacing="0">
"""

FOOT="""</TABLE>
</body>
</html>
"""

sESC="\x1b["
sNORMAL="0;"
sBOLD="1;"
sBLACK="30m"
sRED="31m"
sGREEN="32m"
sYELLOW="33m"
sBLUE="34m"
sMAGENTA="35m"
sCYAN="36m"
sWHITE="37m"
sRESET="39m"

# Define color for messages
BOLD=sESC+sBOLD+sRESET
DONE=sESC+sBOLD+sGREEN
SKIP=sESC+sBOLD+sBLUE
WARN=sESC+sBOLD+sMAGENTA
FAIL=sESC+sBOLD+sRED
NORMAL=sESC+sNORMAL+sRESET

DEBUG = 0					  # for debugging 0=Off 1=On

lineNr = 0						# Counter for readed lines

print HEAD					# print HTML-Header

#linelist=[[pos,fgcolor,hgcolor,bold,text]] # definition der Variablenliste 'linelist' 
## pos     = aktuelle Cursorposition
## fgcolor = Vordergrund Farbe
## hgcolor = Hintergrund Farbe
## bold    = ist Bold aktiv (0/1)
## text    = Text

hg_colStr=''					# define variable for Backgroundcolor

while 1:
	try:
		line = raw_input()		# read from standard device
		lineNr += 1				# increment counter
	except EOFError:
		break					# break/exit is "End Of File"


	if len(line)>0 and line[-1]=='\x0d' :		# evtl. vorhandenen '/r' entfernen
		line=line[:-1]

	isBoldOn = 0				# is Bold active ?
	
	linelist = []				# define emty list

	new_String = ""
	new_line_split = []
	colStr = ""
	BoldOn=""
	pos = 0

	line_split = line.split(sESC)		# Split readed line with sESC separator
	cnt_line_split = len(line_split)	# len/count of line_split

	if DEBUG : print DONE + "Line#:",str(lineNr),"\tSplit:",str(cnt_line_split)+ NORMAL

	for splitNr in range(0,cnt_line_split):

		lsStr = line_split[splitNr]		# string of array (line split string)

		if DEBUG : print '\n_'+lsStr+'_'

		num_cnt = 0								# count for numbers

		if splitNr == 0 :						# split nr 0 have not EscapeSequences
			new_String=line_split[0]
			if len(lsStr)>0:
				test_ = [pos,colStr,hg_colStr,BoldOn,lsStr]
				linelist.append(test_)
				pos +=len(lsStr)
		else:
			lsStr_len = len(lsStr)				# Ueberpruefung der Teilstring-Laenge
			if lsStr_len > 5 :
				lsStr_len = 5
			if DEBUG : print "-%i-" %lsStr_len	# Dump der maximal zu Ueberpruefenden Laenge

			for x1 in range(0,lsStr_len):
				found=''
				zeichen=lsStr[x1]
				if DEBUG : print zeichen ,

				if zeichen == ";" :
					if num_cnt == 1 :
						if lsStr[x1-1] == '0' and isBoldOn == 1:
							isBoldOn = 0
							BoldOn=""
							if DEBUG : print '</B>'
							#new_String +='</B>'
							new_line_split.append('</B>')
						elif lsStr[x1-1] == '1' and isBoldOn == 0:
							isBoldOn = 1
							BoldOn=" b"
							if DEBUG : print '<B>'
							#new_String +='<B>'
							new_line_split.append('<B>')
						else:
							print FAIL+'ERROR: BOLD nicht 0 oder 1'+NORMAL
					else:
						print FAIL+'ERROR: >2 Zahlen in fuer BOLD'+NORMAL
					if DEBUG : print '#;#%i' %num_cnt
					num_cnt = 0				# reset count for numbers
					continue
				elif zeichen.isdigit() :
					num_cnt += 1
					if DEBUG : print '#'
					continue
				elif zeichen == "J" :
					found="J"
					if DEBUG : print FAIL+'#J#'+NORMAL
					new_String +='#J#'
					break
				elif zeichen == "H" :
					found="H"
					if DEBUG : print DONE+'#H#'+NORMAL
					new_String +='#H#'
					break
				elif zeichen == "G" :
					found="G"
					if DEBUG : print SKIP+'#G#'+NORMAL
					xx = str(lsStr[x1-num_cnt:x1])
					new_String +='<TAB_'+xx+'>'
					new_line_split.append('<TAB_'+xx+'>')
					pos = eval(xx)
					break
				elif zeichen == "m" :
					found="m"
					if DEBUG : print BOLD+'#m#'+NORMAL
					color = lsStr[x1-1]
					if color == '0' :
						colStr='white'
					elif color == '1' :
						colStr='red'
					elif color == '2' :
						colStr='green'
					elif color == '3' :
						colStr='yellow'
					elif color == '4' :
						colStr='blue'
					elif color == '5' :
						colStr='magenta'
					elif color == '6' :
						colStr='cyan'
					elif color == '7' :
						colStr='black'
					elif color == '8' :
						colStr='888'
					elif color == '9' :
						colStr=''			# reset Color

					#if colStr<>'' : new_String +='<'+ colStr + '>'
					new_line_split.append('<'+ colStr + '>')
					break

			if found <> '' :
				if DEBUG : print "|%s|%i" % (found, num_cnt)
				if colStr<>'' or BoldOn<>'' :
					new_String +='<span class="%s%s">%s</span>' % (colStr,BoldOn,lsStr[x1+1:])
				else:
					new_String +=lsStr[x1+1:]

			_lsStr=lsStr[x1+1:]
			if _lsStr<>'' :
				if not _lsStr.isspace() :
					test_ = [pos,colStr,hg_colStr,BoldOn,_lsStr]
					linelist.append(test_)
				pos +=len(_lsStr)
			new_line_split.append(_lsStr)

### Starte Tabelle <tr>
	if lineNr % 2 != 0 :					# teile durch 2, ist der Rest nicht Null
		print '<tr class="bggray">'
	else :
		print '<tr class="bggray2">'

### Erster Tabelleneintrag 'ZeilenNummer'
	print '\t<td class="tar">%d: </td>' % (lineNr)

### Zweiter Tabelleneintrag 'Beschreibung'
	#for indexNr in range(0,len(linelist)):
	linelist_cnt=len(linelist)
	if linelist_cnt > 0 :

		cnt_bracket=0							# Count string '[' for Tab's
		for cnt in range(0,linelist_cnt): 
			cnt_bracket+=linelist[cnt][4].count('[')

		if DEBUG : print '\t<td class="tar">%d</td>' % (linelist_cnt)			# Test

		if linelist[0][4].count('*') == 3 and linelist_cnt == 5 :				# Find 3x'*'
			for cnt in range(0,13):
				if cnt == 0 : print '\t<td class="b">%s</td>' % (linelist[0][4])
				elif cnt == 2 : print '\t<td class="tac b">%s</td>' % (linelist[1][4])
				elif cnt == 5 : print '\t<td class="tac b">%s</td>' % (linelist[2][4])
				elif cnt == 8 : print '\t<td class="tac b">%s</td>' % (linelist[3][4])
				elif cnt == 11 : print '\t<td class="tac b">%s</td>' % (linelist[4][4])
				else : print '\t<td></td>'
		else :
			cnt_tabs = linelist_cnt-(cnt_bracket*3)
			for cnt in range(0,cnt_tabs) :
				if cnt == 0 : 
					if linelist[cnt][1] or linelist[cnt][2] :
						print '\t<td class="'+linelist[cnt][1]+linelist[cnt][2]+'">',
					else :
						print '\t<td>',
				if linelist[cnt][3] :
					print '<b>'+linelist[cnt][4]+'</b>',
				else :
					print linelist[cnt][4],
			print '</td>'

			if linelist[0][0] == 0 : 
				start = 1
			else :
				start = 0
			for cnt in range(start, 13-cnt_bracket*3 ) :			# Fill empty tabs
				#print '\t<td>%d</td>' %(cnt)
				print '\t<td></td>'

			for cnt in range(cnt_tabs,linelist_cnt) :
				if linelist[cnt][1] or linelist[cnt][2] or linelist[cnt][3] :
					print '\t<td class="tar '+linelist[cnt][1]+linelist[cnt][2]+linelist[cnt][3]+'">',
				else :
					print '\t<td>',
				print linelist[cnt][4]+'</td>'

	else :
		if DEBUG : print '\t<td class="tar">0</td>'	# Fill Tab 2 for dummy
		for cnt in range(0, 13) :			# Fill empty tabs
			#print '\t<td>%d</td>' %(cnt)
			print '\t<td></td>'


### Beende Tabelle </tr>
	print '</tr >'

#	print line_split
	##print lineNr,linelist_cnt,cnt_bracket, cnt_tabs, linelist,'<br>'
	#print "%3d %s<br>" %(lineNr,new_String)
	if DEBUG : print new_line_split
#print FAIL+"Hallo Welt"+NORMAL,"ist OK:",DONE+"ja"+NORMAL
print FOOT
