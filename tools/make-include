#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2008  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################
###############################################################################
#
# System variables
#
###############################################################################

CONFIG_ROOT=/etc/$SNAME		# Configuration rootdir
NICE=10				# Nice level
TARGET=i686			# Default target
KVER=`grep --max-count=1 VER lfs/linux | awk '{ print $3 }' | tr -d '\n'; grep --max-count=1 FULLVER lfs/linux | awk '{ print $3 }' | cut -c 7-| tail -1`
MACHINE_REAL=`uname -m`
GIT_TAG=$(git tag | tail -1)

# Security options
SSP=1
PIE=1
PAX=1

# Parallelism flag
PARALLELISMFLAGS=-j$(( $(grep processor < /proc/cpuinfo | wc -l) * 2 + 1 ))
DISTCC_HOSTS=localhost

PWD=`pwd`
BASENAME=`basename $0`

# Debian specific settings
if [ ! -e /etc/debian_version ]; then
	FULLPATH=`which $0`
else
	if [ -x /usr/bin/realpath ]; then
		FULLPATH=`/usr/bin/realpath $0`
	else
		echo "ERROR: Need to do apt-get install realpath"
		exit 1
	fi
fi

BASEDIR=`echo $FULLPATH | sed "s/\/$BASENAME//g"`
export BASEDIR

###############################################################################
#
# Read the local configuration to override the environment variables
#
###############################################################################

if ! [ -e .config ]; then
	sed -e "s/@UUID@/$(uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid)/" \
	    -e "s/^#UUID=/UUID=/" < $BASEDIR/.config-default > $BASEDIR/.config
fi

. $BASEDIR/.config

###############################################################################
#
# Variables that are not modifyable by .config
#
###############################################################################

if [ 'i686' = $MACHINE_REAL \
	-o 'i586' = $MACHINE_REAL \
	-o 'i486' = $MACHINE_REAL \
	-o 'x86_64' = $MACHINE_REAL ]; then
	IFS_HOST="$(echo $MACHTYPE | sed "s/$(echo $MACHTYPE | cut -d- -f2)/cross/")"
else
	beautify message FAIL
	echo "Can't determine your architecture - $MACHINE_REAL"
	exit 1
fi

if [ 'i686' = $TARGET -o 'i586' = $TARGET \
	-o 'i486' = $TARGET ]; then
	MACHINE=${TARGET}
	MACHINE_REAL=${MACHINE_REAL}
	LINKER=/lib/ld-linux.so.2
	IFS_TARGET="${MACHINE}-pc-linux-gnu"
	CFLAGS="-march=${MACHINE} -O2 -pipe -fomit-frame-pointer"
	CXXFLAGS="${CFLAGS}"
	UCLIBC_TARGET=${MACHINE}-pc-linux-uclibc
	UCLIBC_CFLAGS="-march=${MACHINE} -Os -pipe"
elif [ 'via-c7' = $TARGET ]; then
	MACHINE=i686
	MACHINE_REAL=${MACHINE_REAL}
	LINKER=/lib/ld-linux.so.2
	IFS_TARGET="${MACHINE}-pc-linux-gnu"
	CFLAGS="-march=${MACHINE} -mmmx -msse -msse2 -msse3 -O2 -pipe"
	CXXFLAGS="${CFLAGS}"
	UCLIBC_TARGET=${MACHINE}-pc-linux-uclibc
	UCLIBC_CFLAGS="-march=i386 -Os -pipe"
elif [ 'via-c3' = $TARGET ]; then
	MACHINE=i586
	MACHINE_REAL=${MACHINE_REAL}
	LINKER=/lib/ld-linux.so.2
	IFS_TARGET="${MACHINE}-pc-linux-gnu"
	CFLAGS="-march=c3 -m3dnow -O2 -pipe -fomit-frame-pointer"
	CXXFLAGS="${CFLAGS}"
	UCLIBC_TARGET=${MACHINE}-pc-linux-uclibc
	UCLIBC_CFLAGS="-march=${MACHINE} -Os -pipe"
else
	beautify message FAIL
	echo "Not a valid target arch (i686|i586|i486|i386|via-c7|via-c3) - $TARGET"
	exit 1
fi

mkdir $BASEDIR/log_${MACHINE}/ 2>/dev/null

# Set up what used to be /tools
TOOLS_DIR=/tools_${MACHINE}
CTOOLS_DIR=/cross-tools_${MACHINE}

# Set up /installer
INSTALLER_DIR=/installer

# A place to build the iso
CDROM_DIR=/cdrom

# A place to keep the images
IMAGES_DIR=/images

# include machine in TOOLCHAINNAME
TOOLCHAINNAME=$SNAME-$TOOLCHAINVERSION-toolchain-t${TARGET}-m${MACHINE}

# The place where all uclibc files are stored in
UCLIBC_DIR=/usr/${UCLIBC_TARGET}
UCLIBC_CC_CORE_STATIC_DIR=${UCLIBC_DIR}/gcc-core-static

#UCLIBC_SYSROOT_DIR=${UCLIBC_DIR}/${UCLIBC_TARGET}/sys-root
UCLIBC_SYSROOT_DIR=${INSTALLER_DIR}

###############################################################################
#
# Beautifying variables & presentation & input output interface
#
###############################################################################

## Screen Dimentions
# Find current screen size
if [ -z "${COLUMNS}" ]; then
	COLUMNS=$(stty size)
	COLUMNS=${COLUMNS##* }
fi

# When using remote connections, such as a serial port, stty size returns 0
if [ "${COLUMNS}" = "0" ]; then
	COLUMNS=80
fi

## Measurements for positioning result messages
RESULT_WIDTH=4
TIME_WIDTH=8
OPT_WIDTH=7
VER_WIDTH=10
RESULT_COL=$((${COLUMNS} - $RESULT_WIDTH - 4))
TIME_COL=$((${RESULT_COL} - $TIME_WIDTH - 5))
VER_COL=$((${TIME_COL} - $VER_WIDTH - 5))
OPT_COL=$((${VER_COL} - $OPT_WIDTH - 5))

## Set Cursur Position Commands, used via echo -e
SET_RESULT_COL="\\033[${RESULT_COL}G"
SET_TIME_COL="\\033[${TIME_COL}G"
SET_VER_COL="\\033[${VER_COL}G"
SET_OPT_COL="\\033[${OPT_COL}G"

# Define color for messages
BOLD="\\033[1;39m"
DONE="\\033[1;32m"
SKIP="\\033[1;34m"
WARN="\\033[1;35m"
FAIL="\\033[1;31m"
NORMAL="\\033[0;39m"


################################################################################
#                                                                              #
# Necessary shell functions                                                    #
#                                                                              #
################################################################################

. $BASEDIR/tools/make-buildspy
. $BASEDIR/tools/make-check
. $BASEDIR/tools/make-batch
. $BASEDIR/tools/make-compilers
. $BASEDIR/tools/make-git

evaluate() {
	if [ "$?" -eq "0" ]; then
		beautify message DONE
	else
		EXITCODE=$1
		shift 1
		beautify message FAIL
		$*
		if [ $EXITCODE -ne "0" ]; then
			exit $EXITCODE
		fi
	fi
}

position_cursor()
{
	# ARG1=starting position on screen
	# ARG2=string to be printed
	# ARG3=offset, negative for left movement, positive for right movement, relative to ARG1
	# For example if your starting position is column 50 and you want to print Hello three columns to the right
	# of your starting position, your call will look like this:
	# position_cursor 50 "Hello" 3 (you'll get the string Hello at position 53 (= 50 + 3)
	# If on the other hand you want your string "Hello" to end three columns to the left of position 50,
	# your call will look like this:
	# position_cursor 50 "Hello" -3 (you'll get the string Hello at position 42 (= 50 - 5 -3)
	# If you want to start printing at the exact starting location, use offset 0

	START=$1
	STRING=$2
	OFFSET=$3

	STRING_LENGTH=${#STRING}

	if [ ${OFFSET} -lt 0 ]; then
		COL=$((${START} + ${OFFSET} - ${STRING_LENGTH}))
	else
		COL=$((${START} + ${OFFSET}))
	fi

	SET_COL="\\033[${COL}G"

	echo $SET_COL
} # End of position_cursor()


beautify()
{
	# Commands: build_stage, make_pkg, message, result
	case "$1" in
		message)
			MESSAGE="$3"
			case "$2" in
				DONE)
					echo -ne "${BOLD}${MESSAGE}${NORMAL}${SET_RESULT_COL}[${DONE} DONE ${NORMAL}]\n"
					;;
				WARN)
					echo -ne "${WARN}${MESSAGE}${NORMAL}${SET_RESULT_COL}[${WARN} WARN ${NORMAL}]\n"
					;;	
				FAIL)
					echo -ne "${BOLD}${MESSAGE}${NORMAL}${SET_RESULT_COL}[${FAIL} FAIL ${NORMAL}]\n"
					;;
				SKIP)
					echo -ne "${BOLD}${MESSAGE}${NORMAL}${SET_RESULT_COL}[${SKIP} SKIP ${NORMAL}]\n"
					;;
				ON)
					echo -ne "${BOLD}${MESSAGE}${NORMAL}${SET_RESULT_COL}[${DONE}  ON  ${NORMAL}]\n"
					;;
				OFF)
					echo -ne "${BOLD}${MESSAGE}${NORMAL}${SET_RESULT_COL}[${FAIL} OFF  ${NORMAL}]\n"
					;;
			esac
			;;
		build_stage)
			MESSAGE=$2
			echo -ne "${BOLD}*** ${MESSAGE}${SET_OPT_COL}  options${SET_VER_COL}     version "
			echo -ne "${SET_TIME_COL} time (sec)${SET_RESULT_COL} status${NORMAL}\n"
			;;
		make_pkg)
			echo "$2" | while read PKG_VER PROGRAM OPTIONS
			do
				SET_VER_COL_REAL=`position_cursor $TIME_COL $PKG_VER -3`

				echo -ne "${PROGRAM}"
				if ! [ "$OPTIONS" == "" ]; then
					echo -ne "${SET_OPT_COL}[ ${BOLD}${OPTIONS}${NORMAL} ]"
				fi

				if [ "${PKG_VER}" == "${SNAME}" ] || [ "${PKG_VER}" == "LFS" ]; then
					echo -ne "${SET_RESULT_COL}"
				else
					echo -ne "${SET_VER_COL}[ ${BOLD}${SET_VER_COL_REAL}${PKG_VER}"
					echo -ne "${NORMAL} ]${SET_RESULT_COL}"
				fi
			done
			;;
		result)
			RESULT=$2

			if [ ! $3 ]; then
				PKG_TIME=0
			else
				PKG_TIME=$3
			fi

			SET_TIME_COL_REAL=`position_cursor $RESULT_COL $PKG_TIME -3`
			case "$RESULT" in
				DONE)
					echo -ne "${SET_TIME_COL}[ ${BOLD}${SET_TIME_COL_REAL}$PKG_TIME${NORMAL} ]"
					echo -ne "${SET_RESULT_COL}[${DONE} DONE ${NORMAL}]\n"
					;;
				FAIL)
					echo -ne "${SET_TIME_COL}[ ${BOLD}${SET_TIME_COL_REAL}$PKG_TIME${NORMAL} ]"
					echo -ne "${SET_RESULT_COL}[${FAIL} FAIL ${NORMAL}]\n"
					;;
				SKIP)
					echo -ne "${SET_TIME_COL}[ ${BOLD}${SET_TIME_COL_REAL}$PKG_TIME${NORMAL} ]"
					echo -ne "${SET_RESULT_COL}[${SKIP} SKIP ${NORMAL}]\n"
					;;
			esac
			;;
	esac
} # End of beautify()


get_pkg_ver()
{
	PKG_VER=`grep ^VER $1 | awk '{print $3}'`

	if [ -z $PKG_VER ]; then
		PKG_VER=`grep "Exp " $1 | awk '{print $4}'`
	fi

	if [ ${#PKG_VER} -gt $VER_WIDTH ]; then
		# If a package version number is greater than $VER_WIDTH, we keep the first 4 characters
		# and replace enough characters to fit the resulting string on the screen.  We'll replace
		# the extra character with .. (two dots).  That's why the "+ 2" in the formula below.
		# Example: if we have a 21-long version number that we want to fit into a 10-long space,
		# we have to remove 11 characters.  But if we replace 11 characters with 2 characters, we'll
		# end up with a 12-character long string.  That's why we replace 12 characters with ..
		REMOVE=`expr substr "$PKG_VER" 4 $[ ${#PKG_VER} - $VER_WIDTH + 2 ]`
		PKG_VER=`echo ${PKG_VER/$REMOVE/..}`
	fi

	echo "$PKG_VER"
} # End of get_pkg_ver()

stdumount() {
	sleep 0.3 # Wait one second for finish of processes
	for fs in `mount | grep $BASEDIR/build_${MACHINE} | awk '{print $3}'`; do
		umount $fs #2>/dev/null;
	done
} # End of stdumount()

exiterror() {
	stdumount
	
	beautify message FAIL
 
	echo -ne "${FAIL}ERROR${NORMAL}: ${BOLD}$*${NORMAL}\n"
	[ -z "$LOGFILE" ] || \
	echo "       Check $LOGFILE for errors if applicable"
	build_spy error
	exit 1
} # End of exiterror()

################################################################################
# This is the function that sets the environment of a chroot and enters it     #
################################################################################
entershell() {
	PATH=${TOOLS_DIR}/usr/bin:/bin:/usr/bin:/sbin:/usr/sbin:${TOOLS_DIR}/bin:/usr/${MACHINE_REAL}-linux/bin

	if [ ! -e $LFS/usr/src/lfs/ ]; then
		exiterror "No such file or directory: $LFS/usr/src/lfs/"
	fi
	
	echo -ne "Entering ${BOLD}$MACHINE${NORMAL} LFS chroot, type exit to return to host environment\n"
	
	chroot $LFS $TOOLS_DIR/bin/env -i \
		HOME=/root \
		TERM=$TERM \
		PS1="${BOLD}[chroot-${TARGET}(${MACHINE})]${NORMAL} \u:\w\$ " \
		PATH=$PATH \
		CONFIG_ROOT=${CONFIG_ROOT} \
		VERSION=${VERSION} \
		NAME=${NAME} \
		SNAME=${SNAME} \
		SLOGAN="$SLOGAN" \
		CCACHE_DIR=/usr/src/ccache \
		CCACHE_PREFIX=${CCACHE_PREFIX} \
		CCACHE_HASHDIR=${CCACHE_HASHDIR} \
		DISTCC_DIR=/usr/src/distcc \
		PARALLELISMFLAGS=$PARALLELISMFLAGS \
		LINKER=$LINKER \
		TOOLS_DIR=$TOOLS_DIR \
		INSTALLER_DIR=$INSTALLER_DIR \
		MACHINE="$MACHINE" \
		MACHINE_REAL="$MACHINE_REAL" \
		CFLAGS="$CFLAGS" \
		CXXFLAGS="$CXXFLAGS" \
		IFS_HOST="$IFS_HOST" \
		IFS_TARGET="$IFS_TARGET" \
		KVER=$KVER \
		STAGE=$STAGE \
		STAGE_ORDER=$STAGE_ORDER \
		LOGFILE=`echo $LOGFILE | sed "s,$BASEDIR,/usr/src,g"` \
		bash

	if [ $? -ne 0 ]; then
		exiterror "chroot error"
	else
		stdumount
	fi
} # End of entershell()



################################################################################
# Common checking before entering the chroot and compilling                    #
# Return:0 caller can continue                                                 #
#	:1 skip (nothing to do)                                                #
#	or fail if no script file found                                        #
################################################################################
lfsmakecommoncheck()
{
	# Script present?
	if [ ! -f $BASEDIR/lfs/$1 ]; then
		exiterror "No such file or directory: $BASEDIR/lfs/$1"
	fi

	local PKG_VER=`get_pkg_ver $BASEDIR/lfs/$1`
	beautify make_pkg "$PKG_VER $*"

	# Script slipped?
	local i
	for i in $SKIP_PACKAGE_LIST
	do
		if [ "$i" == "$1" ]; then
			beautify result SKIP
			return 1;
		fi
	done

	echo -e "`date -u '+%b %e %T'`: Building $* " >> $LOGFILE

	cd $BASEDIR/lfs && make -s -f $* MACHINE=$MACHINE LFS_BASEDIR=$BASEDIR MESSAGE="$1\t " download  >> $LOGFILE 2>&1
	if [ $? -ne 0 ]; then
		exiterror "Download error in $1"
	fi

	return 0	# pass all!
} # End of lfsmakecommoncheck()

################################################################################
# This is the function that builds every package in stage "toolchain"	         #
################################################################################
toolchain_make() {
	lfsmakecommoncheck $*
	[ $? == 1 ] && return 0

	local PKG_VER=`get_pkg_ver $BASEDIR/lfs/$1`

	local EXTRA_MAKE=$EXTRA_MAKE

	local PKG_TIME_START=`date +%s`
	cd $BASEDIR/lfs && $EXTRA_MAKE make -f $* \
		CONFIG_ROOT=$CONFIG_ROOT \
		LINKER=$LINKER \
		TOOLS_DIR=$TOOLS_DIR \
		CTOOLS_DIR=$CTOOLS_DIR \
		MACHINE="$MACHINE" \
		MACHINE_REAL="$MACHINE_REAL" \
		IFS_HOST="$IFS_HOST" \
		IFS_TARGET="$IFS_TARGET" \
		LFS_BASEDIR=$BASEDIR \
		LFS=$LFS \
		INSTALLER_DIR=$INSTALLER_DIR \
		PARALLELISMFLAGS=$PARALLELISMFLAGS \
		KVER=$KVER \
		STAGE=$STAGE \
		STAGE_ORDER=$STAGE_ORDER \
		SSP=$SSP \
		PIE=$PIE \
		PAX=$PAX \
		install >> $LOGFILE 2>&1

	local COMPILE_SUCCESS=$?
	local PKG_TIME_END=`date +%s`

	if [ $COMPILE_SUCCESS -ne 0 ]; then
		beautify result FAIL $[ $PKG_TIME_END - $PKG_TIME_START ] $1 $PKG_VER $STAGE_ORDER $STAGE
		exiterror "Building $*";
	else
		beautify result DONE $[ $PKG_TIME_END - $PKG_TIME_START ] $1 $PKG_VER $STAGE_ORDER $STAGE
	fi

	return 0
} # End of toolchain_make()

################################################################################
# This is the function that builds every package in stage "base" and "ipfire"  #
################################################################################
ipfire_make() {
	lfsmakecommoncheck $*
	[ $? == 1 ] && return 0

	local PKG_VER=`get_pkg_ver $BASEDIR/lfs/$1`

	local EXTRA_MAKE=$EXTRA_MAKE
	# When cross-compiling, make sure the kernel is compiled for the target
	[ "$MACHINE" != "$MACHINE_REAL" -a "$1" == "linux" ] && unset EXTRA_MAKE

	# Also, make sure external kernel modules are compiled 64bit
	if grep -qEi 'KERNEL_MOD = yes' $1 ; then
		unset EXTRA_MAKE
	fi
	
	local MYCFLAGS MYCXXFLAGS
	if [ "${STAGE}" = "installer" ]; then
		MYCFLAGS=${UCLIBC_CFLAGS}
		MYCXXFLAGS=${UCLIBC_CFLAGS}
	else
		MYCFLAGS=${CFLAGS}
		MYCXXFLAGS=${CXXFLAGS}
	fi

	local PKG_TIME_START=`date +%s`
	chroot $LFS $TOOLS_DIR/bin/env -i \
		HOME=/root \
		TERM=$TERM \
		PS1='\u:\w\$ ' \
		PATH=$PATH \
		CONFIG_ROOT=${CONFIG_ROOT} \
		VERSION=${VERSION} \
		NAME=${NAME} \
		SNAME=${SNAME} \
		SLOGAN="$SLOGAN" \
		CCACHE_DIR=/usr/src/ccache \
		CCACHE_PREFIX=${CCACHE_PREFIX} \
		CCACHE_HASHDIR=${CCACHE_HASHDIR} \
		DISTCC_DIR=/usr/src/distcc \
		PARALLELISMFLAGS=$PARALLELISMFLAGS \
		LINKER=$LINKER \
		TOOLS_DIR=$TOOLS_DIR \
		INSTALLER_DIR=$INSTALLER_DIR \
		CDROM_DIR=$CDROM_DIR \
		IMAGES_DIR=$IMAGES_DIR \
		UCLIBC_DIR=$UCLIBC_DIR \
		UCLIBC_SYSROOT_DIR=$UCLIBC_SYSROOT_DIR \
		UCLIBC_TARGET=$UCLIBC_TARGET \
		UCLIBC_CC_CORE_STATIC_DIR=${UCLIBC_CC_CORE_STATIC_DIR} \
		MACHINE="$MACHINE" \
		MACHINE_REAL="$MACHINE_REAL" \
		CFLAGS="$MYCFLAGS" \
		CXXFLAGS="$MYCXXFLAGS" \
		IFS_HOST="$IFS_HOST" \
		IFS_TARGET="$IFS_TARGET" \
		KVER=$KVER \
		STAGE=$STAGE \
		STAGE_ORDER=$STAGE_ORDER \
		SSP=$SSP \
		PIE=$PIE \
		PAX=$PAX \
		LOGFILE=`echo $LOGFILE | sed "s,$BASEDIR,/usr/src,g"` \
		bash -x -c "cd /usr/src/lfs && \
		$EXTRA_MAKE make -f $* LFS_BASEDIR=/usr/src install" >>$LOGFILE 2>&1

	local COMPILE_SUCCESS=$?
	local PKG_TIME_END=`date +%s`

	if [ $COMPILE_SUCCESS -ne 0 ]; then
		beautify result FAIL $[ $PKG_TIME_END - $PKG_TIME_START ] $1 $PKG_VER $STAGE_ORDER $STAGE
		exiterror "Building $*";
	else
		beautify result DONE $[ $PKG_TIME_END - $PKG_TIME_START ] $1 $PKG_VER $STAGE_ORDER $STAGE
	fi

	return 0
} # End of ipfire_make()

################################################################################
# This prepares the build environment                                          #
################################################################################
prepareenv() {

	LOGFILE=$BASEDIR/log_${MACHINE}/_build.00-preparation.log
	export LOGFILE
	mkdir -p $BASEDIR/log_${MACHINE}/01_toolchain 2>/dev/null
	mkdir -p $BASEDIR/log_${MACHINE}/02_base 2>/dev/null
	mkdir -p $BASEDIR/log_${MACHINE}/03_${SNAME} 2>/dev/null
	mkdir -p $BASEDIR/log_${MACHINE}/04_misc 2>/dev/null
	mkdir -p $BASEDIR/log_${MACHINE}/05_installer 2>/dev/null
	mkdir -p $BASEDIR/log_${MACHINE}/06_packages 2>/dev/null
  
	#############################################################################
	# Are we running the right shell?                                           #
	#############################################################################
	  
	if [ ! "$BASH" ]; then
		exiterror "BASH environment variable is not set.  You're probably running the wrong shell."
	fi

	if [ -z "${BASH_VERSION}" ]; then
		exiterror "Not running BASH shell."
	fi

	#############################################################################
	# Trap on emergency exit                                                    #
	#############################################################################
	trap "exiterror 'Build process interrupted'" SIGINT SIGTERM SIGKILL SIGSTOP SIGQUIT


	#############################################################################
	# Resetting our nice level                                                  #
	#############################################################################
	echo -ne "Resetting our nice level to $NICE"
	renice $NICE $$ > /dev/null
	if [ `nice` != "$NICE" ]; then
		beautify message FAIL
		exiterror "Failed to set correct nice level"
	else
		beautify message DONE
	fi
	
	# Set SCHED_BATCH
	if [ -x /usr/bin/schedtool ]; then
		echo -ne "Setting kernel schedular to SCHED_BATCH"
		/usr/bin/schedtool -B $$
		if [ $? -eq 0 ]; then
			beautify message DONE
		else
			beautify message FAIL
		fi
	fi

	##############################################################################
	# Checking if running as root user                                           #
	##############################################################################
	echo -ne "Checking if we're running as root user"
	if [ `id -u` != 0 ]; then
		beautify message FAIL
		exiterror "Not building as root"
	else
		beautify message DONE
	fi


	##############################################################################
	# Checking for necessary temporary space                                     #
	##############################################################################
	echo -ne "Checking for necessary space on disk $BASE_DEV"
	BASE_DEV=`df -P -k $BASEDIR | tail -n 1 | awk '{ print $1 }'`
	BASE_ASPACE=`df -P -k $BASEDIR | tail -n 1 | awk '{ print $4 }'`
	if (( 2048000 > $BASE_ASPACE )); then
		BASE_USPACE=`du -skx $BASEDIR | awk '{print $1}'`
		if (( 2048000 - $BASE_USPACE > $BASE_ASPACE )); then
			beautify message FAIL
			exiterror "Not enough temporary space available, need at least 2GB on $BASE_DEV"
		fi
		beautify message DONE
	else
		beautify message DONE
	fi

	##############################################################################
	# Setting security features                                                  #
	##############################################################################

	echo -ne "Stack smashing protector (SSP)"
	if [ $SSP -eq 1 ]; then
		beautify message ON
	else
		beautify message OFF
	fi

	echo -ne "Position independent executeables (PIE)"
	if [ $PIE -eq 1 ]; then
		beautify message ON
	else
		beautify message OFF
	fi

	echo -ne "GRSecurity (PAX)"
	if [ $PAX -eq 1 ]; then
		beautify message ON
	else
		beautify message OFF
	fi

	export SSP PIE PAX

	##############################################################################
	# Building Linux From Scratch system configuration                           #
	##############################################################################
	
	# Set umask
	umask 022

	# Set LFS Directory
	LFS=$BASEDIR/build_${MACHINE}/${SNAME}
	
	# Check /tools symlink
	if [ -h $TOOLS_DIR ]; then
		rm -f $TOOLS_DIR
	fi
	if [ ! -a $TOOLS_DIR ]; then
		ln -s $BASEDIR/build_${MACHINE}/$TOOLS_DIR /
	fi
	if [ ! -h $TOOLS_DIR ]; then
		exiterror "Could not create $TOOLS_DIR symbolic link."
	fi

	# Setup environment
	set +h
	LC_ALL=POSIX
	export LFS LC_ALL
	unset CC CXX CPP LD_LIBRARY_PATH LD_PRELOAD

	# Make some extra directories
	mkdir -p $BASEDIR/build_${MACHINE}/{$TOOLS_DIR,cdrom} 2>/dev/null
	mkdir -p $BASEDIR/{cache,ccache,distcc} 2>/dev/null
	mkdir -p $BASEDIR/cache/{toolchains,patches,tarballs} 2>/dev/null
	mkdir -p $LFS/{$TOOLS_DIR,usr/src} 2>/dev/null
	mkdir -p $LFS/dev/pts
	mkdir -p $LFS/proc
	mkdir -p $LFS/usr/src/{cache,config,doc,lfs,log_${MACHINE},src,ccache,distcc}
	mkdir -p $LFS/{$INSTALLER_DIR,cdrom,images}
	mkdir -p $LFS/etc

	mknod -m 600 $BASEDIR/build/dev/console c 5 1 2>/dev/null
	mknod -m 666 $BASEDIR/build/dev/null c 1 3 2>/dev/null

	# Make all sources and proc available under lfs build
	mount --bind /dev					$LFS/dev
	mount --bind /proc					$LFS/proc
	mount --bind $BASEDIR/cache				$LFS/usr/src/cache
	mount --bind $BASEDIR/ccache				$LFS/usr/src/ccache
	mount --bind $BASEDIR/distcc				$LFS/usr/src/distcc
	mount --bind $BASEDIR/config				$LFS/usr/src/config
	mount --bind $BASEDIR/doc				$LFS/usr/src/doc
	mount --bind $BASEDIR/lfs				$LFS/usr/src/lfs
	mount --bind $BASEDIR/log_${MACHINE}			$LFS/usr/src/log_${MACHINE}
	mount --bind $BASEDIR/src				$LFS/usr/src/src
	mount --bind $BASEDIR/build_${MACHINE}/$TOOLS_DIR	$LFS/$TOOLS_DIR
	mount --bind $BASEDIR/build_${MACHINE}/$CDROM_DIR	$LFS/$CDROM_DIR

	# Run LFS static binary creation scripts one by one
	export CCACHE_DIR=$BASEDIR/ccache
	export CCACHE_HASHDIR=1
	if [ ! -z "$DISTCC_HOSTS" ]; then
		export CCACHE_PREFIX="distcc"
		export DISTCC_DIR=$BASEDIR/distcc
	fi
	
	[ -z "$DISTCC_HOSTS" ] || echo "$DISTCC_HOSTS" > $DISTCC_DIR/hosts

	# Remove pre-install list of installed files in case user erase some files before rebuild
	rm -f $LFS/usr/src/lsalr 2>/dev/null
}

build() {
	clear
	#a prebuilt toolchain package is only used if found in cache
	if [ ! -d $BASEDIR/cache ]; then
		exiterror "Use make.sh downloadsrc first!"
	fi
	cd $BASEDIR/cache/toolchains
	PACKAGE=`ls -v -r $TOOLCHAINNAME.tar.bz2 2> /dev/null | head -n 1`
	#only restore on a clean disk

	local BLD_TIME_START=`date +%s`

	echo -ne "Building for ${BOLD}${TARGET} (${MACHINE}) on ${MACHINE_REAL}${NORMAL}\n"

	build_spy_send_profile &
	build_spy compiling

	if [ -f $BASEDIR/log_${MACHINE}/02_base/stage2-LFS ]; then
		prepareenv
		echo "Using installed toolchain" >> $LOGFILE
		beautify message DONE "Stage toolchain already built or extracted"
	else
		if [ -z "$PACKAGE" ]; then
			echo "Full toolchain compilation"
			prepareenv

			check_toolchain
			
			beautify build_stage "Building toolchain"
			toolchain_build
		else
			echo "Restore from $PACKAGE"
			cd $BASEDIR && tar jxf $BASEDIR/cache/toolchains/$PACKAGE
			prepareenv
		fi
	fi
	
	beautify build_stage "Building base"
	base_build

	beautify build_stage "Building $SNAME"
	ipfire_build

	beautify build_stage "Building miscellaneous"
	misc_build

	beautify build_stage "Building installer"
	installer_build

	beautify build_stage "Building packages"
	packages_build
	
	echo ""
	echo "... and all this hard work for this:"
	ls -sh $BASEDIR/${SNAME}-${VERSION}.${MACHINE}.iso

	local BLD_TIME_END=`date +%s`
	build_spy set duration $[ $BLD_TIME_END - $BLD_TIME_START ]
	build_spy idle
}

gettoolchain() {
	if [ ! -f $BASEDIR/cache/toolchains/$TOOLCHAINNAME.tar.bz2 ]; then
		URL_TOOLCHAIN=$(grep URL_TOOLCHAIN lfs/Config | awk '{ print $3 }')
		DIR_TOOLCHAIN="$BASEDIR/cache/toolchains"

		echo "Loading toolchain for $MACHINE"
		BASEDIR=$BASEDIR DIR_TMP=/tmp DIR_DL=$DIR_TOOLCHAIN \
			sh $BASEDIR/tools/downloader $URL_TOOLCHAIN $TOOLCHAINNAME.tar.bz2

		if [ $? -eq 0 ]; then
			echo -n "Toolchain was successfully downloaded"
			beautify message DONE
		else
			echo -n "ERROR: Downloading toolchain \"$TOOLCHAINNAME\""
			beautify message FAIL
			echo "Precompiled toolchain not always available for every machine"
		fi
	else
		echo -n "Toolchain \"$TOOLCHAINNAME\" is already existing"
		beautify message SKIP
	fi
}
