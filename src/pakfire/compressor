#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2007, 2008, 2009 Michael Tremer & Christian Schmidt           #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

PACKAGE_VERSION="0"
TAR_OPTIONS="--posix --acls --no-recursion --sparse"

decho() {
	echo "$@" >&2
}

function isDir() {
	[ -d "${1}" ]
}

function isFile() {
	[ -f "${1}" ] || [ -h "${1}" ]
}

function add() {
	local file=${1}

	if isDir ${file}; then
		addDir $@
		return $?

	elif isFile ${file}; then
		addFile $@
		return $?
	fi

	return 1
}

function addDir() {
	local dir=${1}
	local file

	#decho "Adding dir ${dir}..."

	local has_children=0

	for file in $(find ${dir} -maxdepth 1); do
		[ "${file}" = "${dir}" ] && continue

		add ${file}

		has_children=1
	done
	
	if [ "${has_children}" = "0" ]; then
		echo "${dir}" >> ${manifest}
	fi
}

function addFile() {
	local file=${1}
	
	#decho "Adding file ${file}..."
	
	echo "${file}" >> ${manifest}
}

function create_manifest() {
	decho "Creating manifest..."
	addDir ${root}

	apply_regexes
	
	local file
	local files=$(<${manifest})
	for file in ${files}; do
		echo "${file#${root}/}"
	done > ${manifest}

	cat ${manifest}
}

function apply_regexes() {
	if [ -z "${regexes}" ]; then
		return
	fi

	local file
	local filelist
	local files=$(<${manifest})
	local regex

	for regex in $(<${regexes}); do
		[ "${regex:0:1}" != "/" ] && regex="/${regex}"
		filelist=$(find ${root}${regex} 2>/dev/null)
		for file in ${files}; do
			grep "${file}" <<<"${filelist}"
		done
	done > ${manifest}
}

function remove_files() {
	local file
	for file in $(<${manifest}); do
		rm -f ${root}${file} 2>/dev/null
	done
}

regexes=
root=
target=

while [ $# -gt 0 ]; do
	case "${1}" in
		--regexes=*)
			regexes=${1#--regexes=}
			;;
		--root=*)
			root=${1#--root=}
			;;
		*)
			if [ -z "${target}" ]; then
				target=${1}
			else
				echo "Unrecognized option: ${1}" >&2
				exit 2
			fi
			;;
	esac
	shift
done

echo "Preparing to do ${target##*/}..."

archieve=$(mktemp)
control=$(mktemp)
info=$(mktemp)
manifest=$(mktemp)

tmp=$(mktemp -d)

create_manifest

echo "Copying files..."
cd ${root} && tar ${TAR_OPTIONS} --create --xz --file=${archieve} --files-from=${manifest}

if [ $? -ne 0 ]; then
	echo "Error." >&2
	exit 1
fi

remove_files

echo "Writing meta-data..."
cat <<EOF >${info}
### $PKG_NAME package

PACKAGE_TARGET="$TARGET"
PACKAGE_VERSION="$PACKAGE_VERSION"

BUILD_HOST="${BUILD_HOST}"
BUILD_DATE="$(date -u)"

# Version info
PKG_NAME="$PKG_NAME"
PKG_VER="$PKG_VER"
PKG_REL="$PKG_REL"
PKG_GROUP="$PKG_GROUP"

PKG_MAINTAINER="$PKG_MAINTAINER"
PKG_LICENSE="$PKG_LICENSE"

PKG_SUMMARY="$PKG_SUMMARY"
PKG_DESCRIPTION="$PKG_DESCRIPTION"

# Dependency info
PKG_DEPS="$PKG_DEPS"
PKG_BUILD_DEPS="$PKG_BUILD_DEPS"

PKG_DATA_SHA1="$(sha1sum ${archieve} | awk '{ print $1 }')"

###
EOF

echo "Writing control file..."
cat <<EOF >${control}
#!/bin/sh

function prein() {
$CONTROL_PREIN
}

function preun() {
$CONTROL_PREUN
}

function postin() {
$CONTROL_POSTIN
}

function postun() {
$CONTROL_POSTUN
}

###
EOF

cat ${archieve} > ${tmp}/data.img
cat ${control}  > ${tmp}/control
cat ${info}     > ${tmp}/info

(cd ${tmp} && find . | cpio -o -H newc --quiet > ${archieve})

cat ${archieve} > ${target}
