#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2009  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

BOLD="\\033[1;39m"
NORMAL="\\033[0;39m"
ERROR="\\033[1;31m"

if [ -e "/lib/network/functions" ]; then
	. /lib/network/functions
elif [ -e "lib/functions" ]; then
	HOME_DIR="lib"
	. lib/functions
else
	echo "Cannot find functions library. Exiting." >&2
	exit 1
fi

function usage() {
	echo -e "${BOLD}Usage $0${NORMAL}:\n"
	case "$1" in
		main|"")
			echo    "This script will help you configuring your network."
			echo
			echo    "You should know that there are three different things:"
			echo
			echo    "    hook: A script to control connections and protocols."
			echo    "    port: A physical connection to somewhere."
			echo    "    zone: A group of ports."
			echo
			echo    "    $0 [global flags] <hook|port|zone> ... or"
			echo    "    $0 [global flags] <cmd line options...>"
			echo
			echo -e "${BOLD}Global flags:${NORMAL}"
			echo    "    --verbose -v  - Turn on verbose mode."
			echo    "    --debug   -d  - Turn on debug mode."
			echo
			echo -e "${BOLD}Command line options:${NORMAL}"
			echo    "    help          - Prints this help message."
			echo    "    start         - Starts the whole network."
			echo    "    stop          - Stops the whole network."
			echo    "    restart       - Restarts the whole network."
			echo    "    reload        - Reloads the whole network."
			echo
			echo    "    hook - Run \"$0 hook help\" for more information."
			echo    "    port - Run \"$0 port help\" for more information."
			echo    "    zone - Run \"$0 zone help\" for more information."
			echo
			;;
		hook*)
			echo -e "${BOLD}Hook configuration:${NORMAL}"
			echo
			echo    "    ${0} [global options] hook <command>"
			echo
			echo -e "${BOLD}1st level commands:${NORMAL}"
			echo -e "    ${BOLD}list:${NORMAL}"
			echo    "        Returns a list of all available hooks."
			echo
			echo
			echo    "    ${0} [global options] hook <hook> <command>"
			echo
			echo -e "${BOLD}2nd level commands:${NORMAL}"
			echo -e "    ${BOLD}help:${NORMAL}"
			echo    "        Displays some help about the given hook."
			echo
			echo    "        Example: $0 hook ethernet help"
			echo
			;;
		port)
			echo -e "${BOLD}Port Configuration:${NORMAL}"
			echo
			echo    "    $0 [global options] port <command> ..."
			echo
			echo -e "${BOLD}Commands:${NORMAL}"
			echo -e "    ${BOLD}show:${NORMAL}"
			echo    "        Displays information about a given port."
			echo
			echo    "        Requires a \"port\"."
			echo    "        Example: $0 port show 00:11:22:33:44:55"
			echo    "                 $0 port show port0"
			echo
			;;
		zone)
			echo -e "${BOLD}Zone Configuration:${NORMAL}"
			echo
			echo    "    $0 [global options] zone <command> ..."
			echo
			echo -e "${BOLD}Commands:${NORMAL}"
			echo -e "    ${BOLD}show:${NORMAL}"
			echo    "        Displays information about a given zone."
			echo
			echo    "        Requires a \"zone\"."
			echo    "        Example: $0 zone show green0"
			echo
			echo -e "    ${BOLD}add:${NORMAL}"
			echo    "        Adds a new zone."
			echo
			echo    "        Requires a \"zone\"."
			echo    "        Example: $0 zone add green0"
			echo
			echo -e "    ${BOLD}del:${NORMAL}"
			echo    "        Deletes a zone."
			echo
			echo    "        Requires a \"zone\"."
			echo    "        Example: $0 zone del green0"
			echo
			echo -e "    ${BOLD}addport:${NORMAL}"
			echo    "        Adds a port to a zone."
			echo
			echo    "        Requires a \"zone\" and \"port\"."
			echo    "        Example: $0 zone addport green0 port0"
			echo
			echo    "        You may also pass a hook and its parameters:"
			echo    "            $0 zone addport green0 port0 vlan 10"
			echo
			echo -e "    ${BOLD}delport:${NORMAL}"
			echo    "        Deletes a port from a zone."
			echo
			echo    "        Requires a \"zone\" and \"port\"."
			echo    "        Example: $0 zone delport green0"
			echo
			echo    "        You may also pass a hook and its parameters:"
			echo    "            $0 zone delport green0 port0 vlan 10"
			echo
	esac
	_exit ${2-1}
}

function debug() {
	if [ -n "$1" ]; then
		DEBUG=$1
		verbose $1
		return
	else
		if [ "$DEBUG" = "1" ]; then
			return 0
		else
			return 1
		fi
	fi
}

function verbose() {
	if [ -n "$1" ]; then
		VERBOSE=$1
		return
	else
		if [ "$VERBOSE" = "1" ]; then
			return 0
		else
			return 1
		fi
	fi
}

function decho() {
	debug && echo -e "${ERROR}$@${NORMAL}" >&2
}

function vecho() {
	verbose && echo -e "$@" >&2
}

function error() {
	echo -e "${ERROR}ERROR${NORMAL}: $@" >&2
	_exit 1
}

function _exit() {
	local code
	local reload

	while [ $# -gt 0 ]; do
		case "$1" in
			--reload)
				reload=1
				;;
			[0-9]*)
				code=$1
				;;
			*)
				error "Unrecognized argument: $1"
				;;
		esac
		shift
	done
	if [ "${reload}" = "1" ]; then
		# Reloading network to apply changes immediately
		vecho "Reloading network settings..."
		cmd $0 reload
	fi

	decho "Exiting with code ${code}."
	exit ${code}
}

function cmd() {
	decho "Running command: $@"
	if debug; then
		DEBUG=${DEBUG} VERBOSE=${VERBOSE} $@
	else
		DEBUG=${DEBUG} VERBOSE=${VERBOSE} $@ >/dev/null
	fi
}

function port_show() {
	local port

	port=$(devicify $1)

	if ! port_exists ${port}; then
		error "Port ${BOLD}${port}${NORMAL} does not exist."
		return 1
	fi

	ip -s link show $port
}

function port_add() {
	local port=${2}
	local zone=${1}
	local hook=${3}
	shift 3
	
	if [ -n "${port}" ]; then
		port=$(macify ${port})
	else
		error "No port given on command line."
		return 1
	fi

	if [ -z "${hook}" ]; then
		hook="ethernet"
	fi

	decho "Function: port_add"
	decho "  Zone: ${zone} Port: ${port} Hook: ${hook} $@"

	if ! zone_exists ${zone}; then
		error "Zone ${BOLD}${zone}${NORMAL} does not exist."
		return 1
	fi

	if [ -z "$port" ]; then
		error "Port ${BOLD}${port}${NORMAL} could not be found."
		return 1
	fi

	if ! device_exists ${port}; then
		error "Port ${BOLD}${port}${NORMAL} does not exist."
		return 1
	fi

	mkdir -p ${CONFIG_PORTS}/${port} 2>/dev/null
	if hook_exists ${hook}; then
		/lib/network/hooks/${hook} --port=${port} --zone=${zone} add $@
		RET=$?
		if [ "$RET" -eq "0" ]; then
			vecho "Successfully added port ${BOLD}${port}${NORMAL} (${hook} $@) to ${BOLD}${zone}${NORMAL}."
		else
			error "Hook ${BOLD}${hook}${NORMAL} exited with $RET."
			return $RET
		fi
	else
		error "Hook ${BOLD}${hook}${NORMAL} does not exist or is not executeable."
		return 1
	fi
}

function port_del() {
	local port
	local zone
	local hook

	zone=$1
	port=$(devicify $2)
	hook=${3-ethernet}

	shift 3

	decho "Function: port_del"
	decho "  Zone: ${zone} Port: ${port} Hook: ${hook}"
	
	if [ -x "/lib/network/hooks/${hook}" ]; then
		cmd /lib/network/port ${port} down ## XXX How do we identify only that one hook?
		cmd /lib/network/hooks/${hook} --port=${port} --zone=${zone} remove $@
		RET=$?
		if [ "$RET" -eq "0" ]; then
			vecho "Successfully removed port ${BOLD}${port}${NORMAL} (${hook} $@) from ${BOLD}${zone}${NORMAL}."
		else
			error "Hook ${BOLD}${hook}${NORMAL} exited with $RET."
			return $RET
		fi
	else
		error "Hook ${BOLD}${hook}${NORMAL} does not exist or is not executeable."
		return 1
	fi
}

function zone_show() {
	local zone
	zone=$1

	if [ -z "$zone" ]; then
		for zone in ${CONFIG_ZONES}/*; do
			zone_show $(basename $zone)
		done
		return
	fi

	if ! zone_exists ${zone}; then
		error "Zone ${BOLD}${zone}${NORMAL} does not exist."
		return 2
	fi

	echo    "##################################################"
	echo -e "# ${ERROR}ZONE INFO - ${zone}${NORMAL}"
	echo    "##################################################"

	# Up or down?
	if device_is_up ${zone}; then
		echo -e "# Device is ${ERROR}up${NORMAL}."
	else
		echo -e "# Device is ${ERROR}down${NORMAL}."
	fi
	echo "#"

	# Ports
	echo -e "# ${ERROR}Ports:${NORMAL}"
	local config
	local port
	for config in ${CONFIG_ZONES}/${zone}/port-*; do
		port=${config##*/}; port=${port#port-}; port=${port%%-*}
		if ZONE=${zone} cmd /lib/network/port ${port} attach ${config} &>/dev/null; then
			echo "#  ${config#port-} is up"
		else
			echo "#  ${config#port-} is down"
		fi
	done
	echo "#"

}

function zone_add() {
	local zone=$1

	if zone_exists ${zone}; then
		error "Zone ${BOLD}${zone}${NORMAL} already exists."
		return 1
	fi
	
	if ! zone_valid_name ${zone}; then
		error "The given zone name is not valid."
		return 1
	fi

	mkdir -p ${CONFIG_ZONES}/${zone}
	vecho "Successfully added zone ${BOLD}${zone}${NORMAL}."
}

function zone_del() {
	local zone=$1

	if ! zone_exists ${zone}; then
		error "Zone ${BOLD}${zone}${NORMAL} does not exist."
		return 1
	fi

	cmd /lib/network/zone --zone=${zone} down
	rm -rf ${CONFIG_ZONES}/${zone}
	vecho "Successfully removed zone ${BOLD}${zone}${NORMAL}."
}

# See what to do
while [ "$#" -gt 0 ]; do
	arg=$1
	shift

	case "$arg" in
		--debug|-d)
			debug 1
			decho "Debug mode enabled."
			;;
		--verbose|-v)
			verbose 1
			vecho "${BOLD}Verbose mode enabled.${NORMAL}"
			;;
		help|-h|--help)
			usage main 0
			;;
		start|stop|reload)
			action=${arg}
			for zone in $(zone_list); do
				zone=${zone##*/}
				decho "Running command: ${HOME_DIR}/zone --zone=${zone} ${action}"
				DEBUG=${DEBUG} VERBOSE=${VERBOSE} ${HOME_DIR}/zone --zone=${zone} ${action}
			done
			_exit $?
			;;
		restart)
			DEBUG=${DEBUG} VERBOSE=${VERBOSE} $0 stop $@
			sleep 1
			DEBUG=${DEBUG} VERBOSE=${VERBOSE} $0 start $@
			_exit $?
			;;
		hook|hooks)
			case "$1" in
				list)
					for i in ${HOOKS_DIR}/*; do
						hook_exists ${i##*/} && echo ${i}
					done
					_exit $?
					;;
				*)
					if hook_exists ${1}; then
						hook=${1}
					else
						usage hook
					fi
			esac
			shift
			case "$1" in
				help|info)
					if hook_exists ${hook}; then
						hook_run ${hook} ${1}
						_exit $?
					else
						error "Hook ${hook} does not exist or is not executeable."
						_exit 1
					fi
					;;
				*)
					usage hook
					;;
			esac
			;;
		p*)
			arg=$1
			shift
			case "$arg" in
				help)
					usage port 0
					;;
				show)
					port_show $@
					_exit $?
					;;
			esac
			;;
		z*)
			arg=$1
			shift
			case "$arg" in
				add)
					zone_add $@
					_exit --reload $?
					;;
				addport)
					port_add $@
					_exit --reload $?
					;;
				config)
					zone=$1; hook=$2; shift 2
					if [ -z "${zone}" ] || [ -z "${hook}" ]; then
						usage config
					fi
					hook_run ${hook} --zone=${zone} config $@
					_exit --reload $?
					;;
				del)
					zone_del $@
					_exit --reload $?
					;;
				delport)
					port_del $@
					_exit --reload $?
					;;
				help)
					usage zone 0
					;;
				list)
					zone_list
					_exit $?
					;;
				show)
					zone_show $@
					_exit $?
					;;
				start|stop)
					zone=$1; shift
					zone_run --zone=${zone} ${arg} $@
					;;
			esac
			;;
		-*)
			error "Option \"$arg\" is not known."
			;;
	esac
done

usage main
