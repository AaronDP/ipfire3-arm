
import os

from udev import *

class DeviceTree:
    def __init__(self, storage):
        self.installer = storage.installer
        self.storage = storage

        # internal data members
        self._devices = []
        self._actions = []

        self._ignoredDisks = []
        for disk in self.storage.ignoredDisks:
            self.addIgnoredDisk(disk)

    def addIgnoredDisk(self, disk):
        self._ignoredDisks.append(disk)
        lvm.lvm_cc_addFilterRejectRegexp(disk)

    def _handleInconsistencies(self, device):
        def reinitializeVG(vg):
            # First we remove VG data
            try:
                vg.destroy()
            except DeviceError:
                # the pvremoves will finish the job.
                self.installer.log.debug("There was an error destroying the VG %s." % vg.name)

            # remove VG device from list.
            self._removeDevice(vg)

            for parent in vg.parents:
                parent.format.destroy()

                # Give the vg the a default format
                kwargs = {"uuid": parent.uuid,
                          "label": parent.diskLabel,
                          "device": parent.path,
                          "exists": parent.exists}
                parent.format = formats.getFormat(*[""], **kwargs)

        if device.type == "lvmvg":
            paths = []
            for parent in device.parents:
                paths.append(parent.path)

            # when zeroMbr is true he wont ask.
            if not device.complete and (self.zeroMbr or \
                    questionReinitILVM(intf=self.intf, \
                        vg_name=device.name, pv_names=paths)):
                reinitializeVG(device)

            elif not device.complete:
                # The user chose not to reinitialize.
                # hopefully this will ignore the vg components too.
                self._removeDevice(device)
                lvm.lvm_cc_addFilterRejectRegexp(device.name)
                lvm.blacklistVG(device.name)
                for parent in device.parents:
                    self._removeDevice(parent, moddisk=False)
                    lvm.lvm_cc_addFilterRejectRegexp(parent.name)

            return

        elif device.type == "lvmlv":
            # we might have already fixed this.
            if device not in self._devices or \
                    device.name in self._ignoredDisks:
                return

            paths = []
            for parent in device.vg.parents:
                paths.append(parent.path)

            if not device.complete and (self.zeroMbr or \
                questionReinitILVM(intf=self.intf, \
                    lv_name=device.name, pv_names=paths)):

                # destroy all lvs.
                for lv in device.vg.lvs:
                    lv.destroy()
                    device.vg._removeLogVol(lv)
                    self._removeDevice(lv)

                reinitializeVG(device.vg)

            elif not device.complete:
                # ignore all the lvs.
                for lv in device.vg.lvs:
                    self._removeDevice(lv)
                    lvm.lvm_cc_addFilterRejectRegexp(lv.name)
                # ignore the vg
                self._removeDevice(device.vg)
                lvm.lvm_cc_addFilterRejectRegexp(device.vg.name)
                lvm.blacklistVG(device.vg.name)
                # ignore all the pvs
                for parent in device.vg.parents:
                    self._removeDevice(parent, moddisk=False)
                    lvm.lvm_cc_addFilterRejectRegexp(parent.name)
            return

    def populate(self):
        """ Locate all storage devices. """
        # each iteration scans any devices that have appeared since the
        # previous iteration
        old_devices = []
        ignored_devices = []
        while True:
            devices = []
            new_devices = udev_get_block_devices()

            for new_device in new_devices:
                found = False
                for old_device in old_devices:
                    if old_device['name'] == new_device['name']:
                        found = True
                        break

                if not found:
                    devices.append(new_device)

            if len(devices) == 0:
                # nothing is changing -- we are finished building devices
                break

            old_devices = new_devices
            self.installer.log.info("Devices to scan: %s" % [d['name'] for d in devices])
            for dev in devices:
                self.addUdevDevice(dev)

        # After having the complete tree we make sure that the system
        # inconsistencies are ignored or resolved.
        for leaf in self.leaves:
            self._handleInconsistencies(leaf)

        self.teardownAll()
        try:
            os.unlink("/etc/mdadm.conf")
        except OSError:
            self.installer.log.info("Failed to unlink /etc/mdadm.conf")

    def teardownAll(self):
        """ Run teardown methods on all devices. """
        for device in self.leaves:
            try:
                device.teardown(recursive=True)
            except (DeviceError, DeviceFormatError, LVMError) as e:
                log.info("teardown of %s failed: %s" % (device.name, e))

    def setupAll(self):
        """ Run setup methods on all devices. """
        for device in self.leaves:
            try:
                device.setup()
            except DeviceError as e:
                log.debug("setup of %s failed: %s" % (device.name, e))

    def _addDevice(self, newdev):
        """ Add a device to the tree.

            Raise ValueError if the device's identifier is already
            in the list.
        """
        if newdev.path in [d.path for d in self._devices]:
            raise ValueError("device is already in tree")

        # make sure this device's parent devices are in the tree already
        for parent in newdev.parents:
            if parent not in self._devices:
                raise DeviceTreeError("parent device not in tree")

        self._devices.append(newdev)
        self.installer.log.debug("added %s (%s) to device tree" % (newdev.name, newdev.type))

    def isIgnored(self, info):
        """ Return True if info is a device we should ignore.

            Arguments:

                info -- a dict representing a udev db entry

            TODO:

                - filtering of SAN/FC devices
                - filtering by driver?

        """
        sysfs_path = udev_device_get_sysfs_path(info)
        name = udev_device_get_name(info)
        if not sysfs_path:
            return None

        if name in self._ignoredDisks:
            return True

        for ignored in self._ignoredDisks:
            if ignored == os.path.basename(os.path.dirname(sysfs_path)):
                # this is a partition on a disk in the ignore list
                return True

        # Ignore partitions found on the raw disks which are part of a
        # dmraidset
        for set in self.getDevicesByType("dm-raid array"):
            for disk in set.parents:
                if disk.name == os.path.basename(os.path.dirname(sysfs_path)):
                    return True

        # Ignore loop and ram devices, we normally already skip these in
        # udev.py: enumerate_block_devices(), but we can still end up trying
        # to add them to the tree when they are slaves of other devices, this
        # happens for example with the livecd
        if name.startswith("loop") or name.startswith("ram"):
            return True

        # FIXME: check for virtual devices whose slaves are on the ignore list

    def handleUdevLUKSFormat(self, info, device):
        if not device.format.uuid:
            log.info("luks device %s has no uuid" % device.path)
            return

        # look up or create the mapped device
        if not self.getDeviceByName(device.format.mapName):
            passphrase = self.__luksDevs.get(device.format.uuid)
            if passphrase:
                device.format.passphrase = passphrase
            else:
                (passphrase, isglobal) = getLUKSPassphrase(self.intf,
                                                    device,
                                                    self.__passphrase)
                if isglobal and device.format.status:
                    self.__passphrase = passphrase

            luks_device = LUKSDevice(device.format.mapName,
                                     parents=[device],
                                     exists=True)
            try:
                luks_device.setup()
            except (LUKSError, CryptoError, DeviceError) as e:
                sefl.installer.log.info("setup of %s failed: %s" % (device.format.mapName, e))
                device.removeChild()
            else:
                self._addDevice(luks_device)
        else:
            self.installer.log.warning("luks device %s already in the tree"
                        % device.format.mapName)

    def handleUdevLVMPVFormat(self, info, device):
        # lookup/create the VG and LVs
        try:
            vg_name = udev_device_get_vg_name(info)
        except KeyError:
            # no vg name means no vg -- we're done with this pv
            return

        vg_device = self.getDeviceByName(vg_name)
        if vg_device:
            vg_device._addDevice(device)
            for lv in vg_device.lvs:
                try:
                    lv.setup()
                except DeviceError as e:
                    self.installer.log.info("setup of %s failed: %s" % (lv.name, e))
        else:
            try:
                vg_uuid = udev_device_get_vg_uuid(info)
                vg_size = udev_device_get_vg_size(info)
                vg_free = udev_device_get_vg_free(info)
                pe_size = udev_device_get_vg_extent_size(info)
                pe_count = udev_device_get_vg_extent_count(info)
                pe_free = udev_device_get_vg_free_extents(info)
                pv_count = udev_device_get_vg_pv_count(info)
            except (KeyError, ValueError) as e:
                self.installer.log.warning("invalid data for %s: %s" % (name, e))
                return

            vg_device = LVMVolumeGroupDevice(vg_name,
                                             device,
                                             uuid=vg_uuid,
                                             size=vg_size,
                                             free=vg_free,
                                             peSize=pe_size,
                                             peCount=pe_count,
                                             peFree=pe_free,
                                             pvCount=pv_count,
                                             exists=True)
            self._addDevice(vg_device)

            try:
                lv_names = udev_device_get_lv_names(info)
                lv_uuids = udev_device_get_lv_uuids(info)
                lv_sizes = udev_device_get_lv_sizes(info)
            except KeyError as e:
                self.installer.log.warning("invalid data for %s: %s" % (name, e))
                return

            if not lv_names:
                self.installer.log.debug("no LVs listed for VG %s" % name)
                return

            lvs = []
            for (index, lv_name) in enumerate(lv_names):
                name = "%s-%s" % (vg_name, lv_name)
                lv_dev = self.getDeviceByName(name)
                if lv_dev is None:
                    lv_uuid = lv_uuids[index]
                    lv_size = lv_sizes[index]
                    lv_device = LVMLogicalVolumeDevice(lv_name,
                                                       vg_device,
                                                       uuid=lv_uuid,
                                                       size=lv_size,
                                                       exists=True)
                    self._addDevice(lv_device)

                    try:
                        lv_device.setup()
                    except DeviceError as e:
                        self.installer.log.info("setup of %s failed: %s"
                                            % (lv_device.name, e))

    def handleUdevMDMemberFormat(self, info, device):
        # either look up or create the array device
        name = udev_device_get_name(info)
        sysfs_path = udev_device_get_sysfs_path(info)

        md_array = self.getDeviceByUuid(device.format.mdUuid)
        if device.format.mdUuid and md_array:
            md_array._addDevice(device)
        else:
            # create the array with just this one member
            # FIXME: why does this exact block appear twice?
            try:
                # level is reported as, eg: "raid1"
                md_level = udev_device_get_md_level(info)
                md_devices = int(udev_device_get_md_devices(info))
                md_uuid = udev_device_get_md_uuid(info)
            except (KeyError, ValueError) as e:
                self.installer.log.warning("invalid data for %s: %s" % (name, e))
                return

            # find the first unused minor
            minor = 0
            while True:
                if self.getDeviceByName("md%d" % minor):
                    minor += 1
                else:
                    break

            md_name = "md%d" % minor
            md_array = MDRaidArrayDevice(md_name,
                                         level=md_level,
                                         minor=minor,
                                         memberDevices=md_devices,
                                         uuid=md_uuid,
                                         sysfsPath=sysfs_path,
                                         exists=True,
                                         parents=[device])
            try:
                md_array.setup()
            except (DeviceError, MDRaidError) as e:
                self.installer.log.info("setup of md array %s failed: %s"
                            % (md_array.name, e))
            self._addDevice(md_array)

    def handleUdevDMRaidMemberFormat(self, info, device):
        name = udev_device_get_name(info)
        sysfs_path = udev_device_get_sysfs_path(info)
        uuid = udev_device_get_uuid(info)
        major = udev_device_get_major(info)
        minor = udev_device_get_minor(info)

        def _all_ignored(rss):
            retval = True
            for rs in rss:
                if rs.name not in self._ignoredDisks:
                    retval = False
                    break
            return retval

        # Have we already created the DMRaidArrayDevice?
        rss = block.getRaidSetFromRelatedMem(uuid=uuid, name=name,
                                            major=major, minor=minor)
        if len(rss) == 0:
            # we ignore the device in the hope that all the devices
            # from this set will be ignored.
            # FIXME: Can we reformat a raid device?
            self.addIgnoredDisk(device.name)
            return

        # We ignore the device if all the rss are in self._ignoredDisks
        if _all_ignored(rss):
            self.addIgnoredDisk(device.name)
            return

        for rs in rss:
            dm_array = self.getDeviceByName(rs.name)
            if dm_array is not None:
                # We add the new device.
                dm_array._addDevice(device)
            else:
                # Activate the Raid set.
                rs.activate(mknod=True)

                # Create the DMRaidArray
                if self.zeroMbr:
                    cb = lambda: True
                else:
                    cb = lambda: questionInitializeDisk(self.intf,
                                                        rs.name)

                # Create the DMRaidArray
                if not self.clearPartDisks or \
                   rs.name in self.clearPartDisks:
                    # if the disk contains protected partitions
                    # we will not wipe the disklabel even if
                    # clearpart --initlabel was specified
                    initlabel = self.reinitializeDisks
                    for protected in self.protectedPartitions:
                        disk_name = re.sub(r'p\d+$', '', protected)
                        if disk_name != protected and \
                           disk_name == rs.name:
                            initlabel = False
                            break

                try:
                    dm_array = DMRaidArrayDevice(rs.name,
                                                 raidSet=rs,
                                                 parents=[device],
                                                 initcb=cb,
                                                 initlabel=initlabel)

                    self._addDevice(dm_array)
                    # Use the rs's object on the device.
                    # pyblock can return the memebers of a set and the
                    # device has the attribute to hold it.  But ATM we
                    # are not really using it. Commenting this out until
                    # we really need it.
                    #device.format.raidmem = block.getMemFromRaidSet(dm_array,
                    #        major=major, minor=minor, uuid=uuid, name=name)
                except DeviceUserDeniedFormatError:
                    # We should ignore the dmraid and its components
                    self.addIgnoredDisk(rs.name)
                    if _all_ignored(rss):
                        self.addIgnoredDisk(device.name)
                    rs.deactivate()

    def handleUdevDeviceFormat(self, info, device):
        name = udev_device_get_name(info)
        sysfs_path = udev_device_get_sysfs_path(info)
        uuid = udev_device_get_uuid(info)
        label = udev_device_get_label(info)
        format_type = udev_device_get_format(info)

        self.installer.log.debug("Type is '%s'" % format_type)

        format = None
        if (not device) or (not format_type) or device.format.type:
            # this device has no formatting or it has already been set up
            # FIXME: this probably needs something special for disklabels
            return

        # set up the common arguments for the format constructor
        args = [format_type]
        kwargs = {"uuid": uuid,
                  "label": label,
                  "device": device.path,
                  "exists": True}

        # set up type-specific arguments for the format constructor
        if format_type == "crypto_LUKS":
            # luks/dmcrypt
            kwargs["name"] = "luks-%s" % uuid
        elif format_type == "linux_raid_member":
            # mdraid
            try:
                kwargs["mdUuid"] = udev_device_get_md_uuid(info)
            except KeyError:
                log.debug("mdraid member %s has no md uuid" % name)
        elif format_type == "LVM2_member":
            # lvm
            try:
                kwargs["vgName"] = udev_device_get_vg_name(info)
            except KeyError as e:
                log.debug("PV %s has no vg_name" % name)
            try:
                kwargs["vgUuid"] = udev_device_get_vg_uuid(info)
            except KeyError:
                log.debug("PV %s has no vg_uuid" % name)
            try:
                kwargs["peStart"] = udev_device_get_pv_pe_start(info)
            except KeyError:
                log.debug("PV %s has no pe_start" % name)
        elif format_type == "vfat":
            # efi magic
            if isinstance(device, PartitionDevice) and device.bootable:
                efi = formats.getFormat("efi")
                if efi.minSize <= device.size <= efi.maxSize:
                    args[0] = "efi"

        device.format = formats.getFormat(*args, **kwargs)

        #
        # now do any special handling required for the device's format
        #
        if device.format.type == "luks":
            self.handleUdevLUKSFormat(info, device)
        elif device.format.type == "mdmember":
            self.handleUdevMDMemberFormat(info, device)
        elif device.format.type == "dmraidmember":
            self.handleUdevDMRaidMemberFormat(info, device)
        elif device.format.type == "lvmpv":
            self.handleUdevLVMPVFormat(info, device)

    def addUdevDMDevice(self, info):
        name = udev_device_get_name(info)
        log_method_call(self, name=name)
        uuid = udev_device_get_uuid(info)
        sysfs_path = udev_device_get_sysfs_path(info)
        device = None

        for dmdev in self.devices.values():
            if not isinstance(dmdev, DMDevice):
                continue

            try:
                # there is a device in the tree already with the same
                # major/minor as this one but with a different name
                # XXX this is kind of racy
                if dmdev.getDMNode() == os.path.basename(sysfs_path):
                    # XXX should we take the name already in use?
                    device = dmdev
                    break
            except DMError:
                # This is a little lame, but the VG device is a DMDevice
                # and it won't have a dm node. At any rate, this is not
                # important enough to crash the install.
                self.installer.log.debug("Failed to find dm node for %s" % dmdev.name)
                continue

        if device is None:
            # we couldn't find it, so create it
            # first, get a list of the slave devs and look them up
            slaves = []
            dir = os.path.normpath("/sys/%s/slaves" % sysfs_path)
            slave_names = os.listdir(dir)
            for slave_name in slave_names:
                # if it's a dm-X name, resolve it to a map name first
                if slave_name.startswith("dm-"):
                    dev_name = dm.name_from_dm_node(slave_name)
                else:
                    dev_name = slave_name
                slave_dev = self.getDeviceByName(dev_name)
                if slave_dev:
                    slaves.append(slave_dev)
                else:
                    # we haven't scanned the slave yet, so do it now
                    path = os.path.normpath("%s/%s" % (dir, slave_name))
                    new_info = udev_get_block_device(os.path.realpath(path))
                    if new_info:
                        self.addUdevDevice(new_info)
                        if self.getDeviceByName(dev_name) is None:
                            # if the current slave is still not in
                            # the tree, something has gone wrong
                            self.installer.log.error("Failure scanning device %s: could not add slave %s" % (name, dev_name))
                            return

            # try to get the device again now that we've got all the slaves
            device = self.getDeviceByName(name)

            if device is None and \
                    udev_device_is_dmraid_partition(info, self):
                diskname = udev_device_get_dmraid_partition_disk(info)
                disk = self.getDeviceByName(diskname)
                device = PartitionDevice(name, sysfsPath=sysfs_path,
                                         major=udev_device_get_major(info),
                                         minor=udev_device_get_minor(info),
                                         exists=True, parents=[disk])
                # DWL FIXME: call self.addUdevPartitionDevice here instead
                self._addDevice(device)

            # if we get here, we found all of the slave devices and
            # something must be wrong -- if all of the slaves are in
            # the tree, this device should be as well
            if device is None:
                self.installer.log.warning("Using generic DM device for %s" % name)
                device = DMDevice(name, exists=True, parents=slaves)
                self._addDevice(device)

        return device

    def addUdevMDDevice(self, info):
        name = udev_device_get_name(info)
        uuid = udev_device_get_uuid(info)
        sysfs_path = udev_device_get_sysfs_path(info)
        device = None

        slaves = []
        dir = os.path.normpath("/sys/%s/slaves" % sysfs_path)
        slave_names = os.listdir(dir)
        for slave_name in slave_names:
            # if it's a dm-X name, resolve it to a map name
            if slave_name.startswith("dm-"):
                dev_name = dm.name_from_dm_node(slave_name)
            else:
                dev_name = slave_name
            slave_dev = self.getDeviceByName(dev_name)
            if slave_dev:
                slaves.append(slave_dev)
            else:
                # we haven't scanned the slave yet, so do it now
                path = os.path.normpath("%s/%s" % (dir, slave_name))
                new_info = udev_get_block_device(os.path.realpath(path))
                if new_info:
                    self.addUdevDevice(new_info)
                    if self.getDeviceByName(dev_name) is None:
                        # if the current slave is still not in
                        # the tree, something has gone wrong
                        self.installer.log.error("Failure scanning device %s: could not add slave %s" % (name, dev_name))
                        return

        # try to get the device again now that we've got all the slaves
        device = self.getDeviceByName(name)

        # if we get here, we found all of the slave devices and
        # something must be wrong -- if all of the slaves we in
        # the tree, this device should be as well
        if device is None:
            self.installer.log.warning("Using MD RAID device for %s" % name)
            try:
                # level is reported as, eg: "raid1"
                md_level = udev_device_get_md_level(info)
                md_devices = int(udev_device_get_md_devices(info))
                md_uuid = udev_device_get_md_uuid(info)
            except (KeyError, IndexError, ValueError) as e:
                self.installer.log.warning("Invalid data for %s: %s" % (name, e))
                return

            device = MDRaidArrayDevice(name,
                                       level=md_level,
                                       memberDevices=md_devices,
                                       uuid=md_uuid,
                                       exists=True,
                                       parents=slaves)
            self._addDevice(device)

        return device

    def addUdevPartitionDevice(self, info):
        name = udev_device_get_name(info)
        uuid = udev_device_get_uuid(info)
        sysfs_path = udev_device_get_sysfs_path(info)
        device = None

        disk_name = os.path.basename(os.path.dirname(sysfs_path))
        disk = self.getDeviceByName(disk_name)

        if disk is None:
            # create a device instance for the disk
            path = os.path.dirname(os.path.realpath(sysfs_path))
            new_info = udev_get_block_device(path)
            if new_info:
                self.addUdevDevice(new_info)
                disk = self.getDeviceByName(disk_name)

            if disk is None:
                # if the current device is still not in
                # the tree, something has gone wrong
                self.installer.log.error("Failure scanning device %s" % disk_name)
                return

        try:
            device = PartitionDevice(name, sysfsPath=sysfs_path,
                                     major=udev_device_get_major(info),
                                     minor=udev_device_get_minor(info),
                                     exists=True, parents=[disk])
        except DeviceError:
            # corner case sometime the kernel accepts a partition table
            # which gets rejected by parted, in this case we will
            # prompt to re-initialize the disk, so simply skip the
            # faulty partitions.
            return

        self._addDevice(device)
        return device

    def addUdevDiskDevice(self, info):
        name = udev_device_get_name(info)
        log_method_call(self, name=name)
        uuid = udev_device_get_uuid(info)
        sysfs_path = udev_device_get_sysfs_path(info)
        device = None

        kwargs = {}
        diskType = DiskDevice
        self.installer.log.debug("%s is a disk" % name)
        cb = lambda: questionInitializeDisk(self.intf, name)

        # if the disk contains protected partitions we will
        # not wipe the disklabel even if clearpart --initlabel
        # was specified

        initlabel = self.reinitializeDisks
        for protected in self.protectedPartitions:
            _p = "/sys/%s/%s" % (sysfs_path, protected)
            if os.path.exists(os.path.normpath(_p)):
                initlabel = False
                break

        try:
            device = diskType(name,
                              major=udev_device_get_major(info),
                              minor=udev_device_get_minor(info),
                              sysfsPath=sysfs_path,
                              initcb=cb, initlabel=initlabel, **kwargs)
        except DeviceUserDeniedFormatError: #drive not initialized?
            self.addIgnoredDisk(name)
            return

        self._addDevice(device)
        return device

    def addUdevDevice(self, info):
        # FIXME: this should be broken up into more discrete chunks
        name = udev_device_get_name(info)
        uuid = udev_device_get_uuid(info)
        sysfs_path = udev_device_get_sysfs_path(info)

        if self.isIgnored(info):
            self.installer.log.debug("Ignoring %s (%s)" % (name, sysfs_path))
            return

        self.installer.log.debug("Scanning %s (%s)..." % (name, sysfs_path))
        device = self.getDeviceByName(name)

        #
        # The first step is to either look up or create the device
        #
        if udev_device_is_dm(info):
            self.installer.log.debug("%s is a device-mapper device" % name)
            # try to look up the device
            if device is None and uuid:
                # try to find the device by uuid
                device = self.getDeviceByUuid(uuid)

            if device is None:
                device = self.addUdevDMDevice(info)
        elif udev_device_is_md(info):
            self.installer.log.debug("%s is an md device" % name)
            if device is None and uuid:
                # try to find the device by uuid
                device = self.getDeviceByUuid(uuid)

            if device is None:
                device = self.addUdevMDDevice(info)
        elif udev_device_is_cdrom(info):
            self.installer.log.debug("%s is a cdrom" % name)
            if device is None:
                device = self.addUdevOpticalDevice(info)
        elif udev_device_is_dmraid(info):
            # This is special handling to avoid the "unrecognized disklabel"
            # code since dmraid member disks won't have a disklabel. We
            # use a StorageDevice because DiskDevices need disklabels.
            # Quite lame, but it doesn't matter much since we won't use
            # the StorageDevice instances for anything.
            self.installer.log.debug("%s is part of a dmraid" % name)
            if device is None:
                device = StorageDevice(name,
                                major=udev_device_get_major(info),
                                minor=udev_device_get_minor(info),
                                sysfsPath=sysfs_path, exists=True)
                self._addDevice(device)
        elif udev_device_is_disk(info):
            if device is None:
                device = self.addUdevDiskDevice(info)
        elif udev_device_is_partition(info):
            self.installer.log.debug("%s is a partition" % name)
            if device is None:
                device = self.addUdevPartitionDevice(info)

        # now handle the device's formatting
        self.handleUdevDeviceFormat(info, device)

    def getDeviceBySysfsPath(self, path):
        found = None
        for device in self._devices:
            if device.sysfsPath == path:
                found = device
                break

        return found

    def getDeviceByUuid(self, uuid):
        found = None
        for device in self._devices:
            if device.uuid == uuid:
                found = device
                break
            elif device.format.uuid == uuid:
                found = device
                break

        return found

    def getDeviceByLabel(self, label):
        found = None
        for device in self._devices:
            _label = getattr(device.format, "label", None)
            if not _label:
                continue

            if _label == label:
                found = device
                break

        return found

    def getDeviceByName(self, name):
        self.installer.log.debug("Looking for device '%s'..." % name)
        self.installer.log.debug("All devices: %s" % self._devices)
        found = None
        for device in self._devices:
            if device.name == name:
                found = device
                break

        self.installer.log.debug("Found %s" % found)
        return found

    def getDevicesByType(self, device_type):
        # TODO: expand this to catch device format types
        return [d for d in self._devices if d.type == device_type]

    def getDevicesByInstance(self, device_class):
        return [d for d in self._devices if isinstance(d, device_class)]

    @property
    def devices(self):
        """ Dict with device path keys and Device values. """
        devices = {}

        for device in self._devices:
            if device.path in devices:
                raise DeviceTreeError("duplicate paths in device tree")

            devices[device.path] = device

        return devices

    @property
    def filesystems(self):
        """ List of filesystems. """
        #""" Dict with mountpoint keys and filesystem values. """
        filesystems = []
        for dev in self.leaves:
            if dev.format and getattr(dev.format, 'mountpoint', None):
                filesystems.append(dev.format)

        return filesystems

    @property
    def uuids(self):
        """ Dict with uuid keys and Device values. """
        uuids = {}
        for dev in self._devices:
            try:
                uuid = dev.uuid
            except AttributeError:
                uuid = None

            if uuid:
                uuids[uuid] = dev

            try:
                uuid = dev.format.uuid
            except AttributeError:
                uuid = None

            if uuid:
                uuids[uuid] = dev

        return uuids

    @property
    def labels(self):
        """ Dict with label keys and Device values.

            FIXME: duplicate labels are a possibility
        """
        labels = {}
        for dev in self._devices:
            if dev.format and getattr(dev.format, "label", None):
                labels[dev.format.label] = dev

        return labels

    @property
    def leaves(self):
        """ List of all devices upon which no other devices exist. """
        leaves = [d for d in self._devices if d.isleaf]
        return leaves

    def getChildren(self, device):
        """ Return a list of a device's children. """
        return [c for c in self._devices if device in c.parents]

    def resolveDevice(self, devspec, blkidTab=None, cryptTab=None):
        # find device in the tree
        device = None
        if devspec.startswith("UUID="):
            # device-by-uuid
            uuid = devspec.partition("=")[2]
            device = self.uuids.get(uuid)
            if device is None:
                self.installer.log.error("Failed to resolve device %s" % devspec)
        elif devspec.startswith("LABEL="):
            # device-by-label
            label = devspec.partition("=")[2]
            device = self.labels.get(label)
            if device is None:
                self.installer.log.error("Failed to resolve device %s" % devspec)
        elif devspec.startswith("/dev/"):
            # device path
            device = self.devices.get(devspec)
            if device is None:
                if blkidTab:
                    # try to use the blkid.tab to correlate the device
                    # path with a UUID
                    blkidTabEnt = blkidTab.get(devspec)
                    if blkidTabEnt:
                        self.installer.log.debug("Found blkid.tab entry for '%s'" % devspec)
                        uuid = blkidTabEnt.get("UUID")
                        if uuid:
                            device = self.getDeviceByUuid(uuid)
                            if device:
                                devstr = device.name
                            else:
                                devstr = "None"
                            self.installer.log.debug("Found device '%s' in tree" % devstr)
                        if device and device.format and \
                           device.format.type == "luks":
                            map_name = device.format.mapName
                            self.installer.log.debug("Luks device; map name is '%s'" % map_name)
                            mapped_dev = self.getDeviceByName(map_name)
                            if mapped_dev:
                                device = mapped_dev

                if device is None and cryptTab and \
                   devspec.startswith("/dev/mapper/"):
                    # try to use a dm-crypt mapping name to 
                    # obtain the underlying device, possibly
                    # using blkid.tab
                    cryptTabEnt = cryptTab.get(devspec.split("/")[-1])
                    if cryptTabEnt:
                        luks_dev = cryptTabEnt['device']
                        try:
                            device = self.getChildren(luks_dev)[0]
                        except IndexError as e:
                            pass
                elif device is None:
                    # dear lvm: can we please have a few more device nodes
                    #           for each logical volume?
                    #           three just doesn't seem like enough.
                    name = devspec[5:]      # strip off leading "/dev/"
                    (vg_name, slash, lv_name) = name.partition("/")
                    if lv_name and not "/" in lv_name:
                        # looks like we may have one
                        lv = "%s-%s" % (vg_name, lv_name)
                        device = self.getDeviceByName(lv)

        if device:
            self.installer.log.debug("Resolved '%s' to '%s' (%s)" % (devspec, device.name, device.type))
        else:
            self.installer.log.debug("Failed to resolve '%s'" % devspec)
        return device
