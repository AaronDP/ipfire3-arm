#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2008  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

. /usr/libexec/initramfs-functions

if [ $UID != 0 ]; then
	error "$0 must be run as root."
	exit 1
fi

usage() {
	if [ "$1" == "-n" ]; then
		cmd=echo
	else
		cmd=error
	fi

	$cmd "usage: `basename $0` [--version] [--help] [-v] [-f] [--preload <module>]"
	$cmd "       [--force-scsi-probe | --omit-scsi-modules]"
	$cmd "       [--with=<module>] [--builtin=<module>]"
	$cmd "       [--fstab=<fstab>] <initrd-image> <kernel-version>"
	$cmd ""
	$cmd "       (ex: `basename $0` /boot/initrd-2.2.5-15.img 2.2.5-15)"

	if [ "$1" == "-n" ]; then
		exit 0
	else
		exit 1
	fi
}

fstab="/etc/fstab"
modulefile=/etc/modprobe.conf

LD_SO_CONF=/etc/ld.so.conf
LD_SO_CONF_D=/etc/ld.so.conf.d/

cemit()
{
	cat >> $RCFILE
}

emit()
{
	echo "$@" >> $RCFILE
}

read_link() {
	READLINK=$(readlink $1)
	if grep -q "^/" <<< $READLINK; then
		echo $READLINK
	else
		echo "$(dirname $1)/$READLINK"
	fi
}

resolve_device_name() {
	if [[ "$1" =~ ^/dev ]]; then
		echo $1
	else
		findfs $1
	fi
}

# resolve a device node to its major:minor numbers in decimal or hex
get_numeric_dev() {
	(	fmt="%d:%d"
		if [ "$1" == "hex" ]; then
			fmt="%x:%x"
		fi
		ls -lH "$2" | awk '{ sub(/,/, "", $5); printf("'"$fmt"'", $5, $6); }'
	) 2>/dev/null
}

scsi_wait_scan="no"
findmodule() {
	skiperrors=""

	if [ $1 == "--skiperrors" ]; then
		skiperrors=--skiperrors
		shift
	fi

	local modName=$1

	if [ "$modName" = "off" -o "$modName" = "null" ]; then
		return
	fi

	if [ "$modName" != "${modName##-}" ]; then
		skiperrors=--skiperrors
		modName="${modName##-}"
	fi

	case "$MODULES " in
		*"/$modName.ko "*) return ;;
	esac

	if echo $builtins | egrep -q '(^| )'$modName'( |$)' ; then
		vecho "module $modName assumed to be built in"
		return
    fi

	# special cases
	if [ "$modName" = "i2o_block" ]; then
		findmodule i2o_core
		findmodule -i2o_pci
		modName="i2o_block"
	elif [ "$modName" = "ppa" ]; then
		findmodule parport
		findmodule parport_pc
		modName="ppa"
	elif [ "$modName" = "sbp2" ]; then
		findmodule ieee1394
		findmodule ohci1394
		modName="sbp2"
	elif [ "$modName" = "fw-sbp2" ]; then
		findmodule fw-core
		findmodule fw-ohci
		modName="fw-sbp2"
	elif [ "$modName" = "firewire-sbp2" ]; then
		findmodule firewire-core
		findmodule firewire-ohci
		modName="firewire-sbp2"
	elif [ "$modName" = "usb-storage" -o "$modName" = "ub" ]; then
		usbModName="$modName"
	fi

	if [ -n "$usbModName" \
		 -a "$modName" != "uhci-hcd" \
		 -a "$modName" != "ohci-hcd" \
		 -a "$modName" != "ehci-hcd" ]; then
		withusb=1
		findmodule ehci-hcd
		findmodule ohci-hcd
		findmodule uhci-hcd

		usbModName=""
	fi

	locatemodule $modName

	if [ ! -f "$fmPath" ]; then
		if [ -n "$skiperrors" ]; then
			return
		fi

		# ignore the absence of the scsi modules
		for n in $PRESCSIMODS; do
			if [ "$n" = "$modName" ]; then
				return;
			fi
		done;

		if [ -n "$allowmissing" ]; then
			error "WARNING: No module $modName found for kernel $kernel, continuing anyway"
			return
		fi

		error "No module $modName found for kernel $kernel, aborting."
		exit 1
	fi

	# only need to add each module once
	[[ "$MODULES" =~ "$modName" ]] || MODULES="$MODULES $modName"

	# need to handle prescsimods here -- they need to go _after_ scsi_mod
	if [ "$modName" = "scsi_mod" ]; then
		for n in $PRESCSIMODS ; do
			findmodule $n
		done
		locatemodule scsi_wait_scan
		if [ -n "$fmPath" -a -f "$fmPath" ]; then
			scsi_wait_scan="yes"
		fi
	fi
}

finddevnoinsys() {
	majmin="$1"
	if [ -n "$majmin" ]; then
		dev=$(for x in /sys/block/* ; do findall $x/ -name dev ; done | while read device ; do \
			echo "$majmin" | cmp -s $device && echo $device ; done)
		if [ -n "$dev" ]; then
			dev=${dev%%/dev}
			dev=${dev%%/}
			echo "$dev"
			return 0
		fi
	fi
	return 1
}

findblockdevinsys() {
	devname=$(resolve_device_name "$1")
	if [[ "$devname" =~ ^/sys/block/ ]]; then
		echo "$devname"
	fi
	majmin=$(get_numeric_dev dec $devname)
	finddevnoinsys "$majmin"
}

slavestried=""
findstoragedriverinsys () {
	while [ ! -L device ]; do
		for slave in $(ls -d slaves/* 2>/dev/null) ; do
			slavename=${slave##*/}
			case " $slavestried " in
				*" $slavename "*)
					continue
					;;
				*)
					slavestried="$slavestried $slavename"
					qpushd $slave
					findstoragedriverinsys
					qpopd
					;;
			esac
		done
		[ "$PWD" = "/sys" ] && return
		cd ..
	done
	cd $(read_link ./device)
	if echo $PWD | grep -q /virtio-pci/ ; then
		findmodule virtio_pci
	fi
	while [ "$PWD" != "/sys/devices" ]; do
		deps=
		if [ -f modalias ]; then
			moduledep $(cat modalias)
		fi

		[ -z "$deps" -a -L driver/module ] && \
			deps=$(basename $(read_link driver/module))
		for driver in $deps; do
			findmodule $driver
		done
		cd ..
	done
}

findstoragedriver () {
	for device in $@ ; do
		case " $handleddevices " in
			*" $device "*)
				continue ;;
			*) handleddevices="$handleddevices $device" ;;
		esac
		vecho "Looking for driver for device $device"
		if [[ "$device" =~ ^/sys ]]; then
			device=${device##*/}
		fi
		sysfs=""
		device=$(echo "$device" | sed 's,/,!,g')
		if [ -d /sys/block/$device/ ]; then
			sysfs="/sys/block/$device"
		else
			sysfs=$(for x in /sys/block/* ; do findone $x/ -type d -name $device; done)
		fi
		[ -z "$sysfs" ] && return
		qpushd $sysfs
		findstoragedriverinsys
		qpopd
	done
}

# exclude specific modules
# (must be done before resolution of deps)
excludemods() {
	items="$*"
	output=""
	for i in $items; do
		for x in $excludemodules; do
			if [ "$i" = "$x" ]; then
				continue 2
			fi
		done
		output="$output $i"
	done
	echo $output
}

savedargs=$*
while [ $# -gt 0 ]; do
	case $1 in
		--fstab*)
			if [ "$1" != "${1##--fstab=}" ]; then
				fstab=${1##--fstab=}
			else
				fstab=$2
				shift
			fi
			;;

		--with-usb*)
			if [ "$1" != "${1##--with-usb=}" ]; then
				usbmodule=${1##--with-usb=}
			else
				usbmodule="usb-storage"
			fi
			basicmodules="$basicmodules $usbmodule"
			unset usbmodule
			;;

		--without-usb)
			withusb=0
			;;

		--with-avail*)
			if [ "$1" != "${1##--with-avail=}" ]; then
				modname=${1##--with-avail=}
			else
				modname=$2
				shift
			fi

			availmodules="$availmodules $modname"
			;;

		--without*)
			if [ "$1" != "${1##--without=}" ]; then
				modname=${1##--without=}
			else
				modname=$2
				shift
			fi

			excludemodules="$excludemodules $modname"
			;;

		--with*)
			if [ "$1" != "${1##--with=}" ]; then
				modname=${1##--with=}
			else
				modname=$2
				shift
			fi

			basicmodules="$basicmodules $modname"
			;;

		--builtin*)
			if [ "$1" != "${1##--builtin=}" ]; then
				modname=${1##--builtin=}
			else
				modname=$2
				shift
			fi

			builtins="$builtins $modname"
			;;

		-v)
			set_verbose true
			;;

		-f)
			force=1
			;;
		--preload*)
			if [ "$1" != "${1##--preload=}" ]; then
				modname=${1##--preload=}
			else
				modname=$2
				shift
			fi
			PREMODS="$PREMODS $modname"
			;;

		--force-scsi-probe)
			forcescsi=1
			;;

		--omit-scsi-modules)
			PRESCSIMODS=""
			noscsi=1
			;;

		--allow-missing)
			allowmissing=yes
			;;

		--rootdev*)
			if [ "$1" != "${1##--rootdev=}" ]; then
				rootdev="${1##--rootdev=}"
			else
				rootdev="$2"
				shift
			fi
			;;

		--rootfs*)
			if [ "$1" != "${1##--rootfs=}" ]; then
				rootfs="${1##--rootfs=}"
			else
				rootfs="$2"
				shift
			fi
			;;

		--rootopts*)
			if [ "$1" != "${1##--rootopts=}" ]; then
				rootopts="${1##--rootopts=}"
			else
				rootopts="$2"
				shift
			fi
			;;

		--help)
			usage -n
			;;
		*)
			if [ -z "$target" ]; then
				target=$1
			elif [ -z "$kernel" ]; then
				kernel=$1
			else
				usage
			fi
			;;
	esac

	shift
done

if [ -z "$target" -o -z "$kernel" ]; then
	usage
fi

sleep 10 # Just wait a time...

TMPDIR=""
for t in /tmp /var/tmp /root ${PWD}; do
	if [ ! -d $t ]; then continue; fi
	if ! test -w $t ; then continue; fi

	fs=$(df -T $t 2>/dev/null | awk '{line=$1;} END {printf $2;}')
	if [ "$fs" != "tmpfs" ]; then
		TMPDIR=$t
		break
	fi
done

if [ -z "$TMPDIR" ]; then
	error "no temporary directory could be found."
	exit 1
fi

if [ $TMPDIR = "/root" -o $TMPDIR = "${PWD}" ]; then
	error "WARNING: using $TMPDIR for temporary files"
fi

if [ "$withusb" == "1" ]; then
	findmodule ehci-hcd
	findmodule ohci-hcd
	findmodule uhci-hcd
fi

[ -z "$rootfs" ] && rootfs=$(awk '{ if ($1 !~ /^[ \t]*#/ && $2 == "/") { print $3; }}' $fstab)
[ -z "$rootopts" ] && rootopts=$(awk '{ if ($1 !~ /^[ \t]*#/ && $2 == "/") { print $4; }}' $fstab)
[ -z "$rootopts" ] && rootopts="defaults"

# in case the root filesystem is modular
findmodule -${rootfs}

[ -z "$rootdev" ] && rootdev=$(awk '/^[ \t]*[^#]/ { if ($2 == "/") { print $1; }}' $fstab)

# check if it's root by label
rdev=$rootdev
if [[ "$rdev" =~ "^(UUID=|LABEL=)" ]]; then
	rdev=$(resolve_device_name "$rdev")
fi
rootopts=$(echo $rootopts | sed -e 's/^r[ow],//' -e 's/,_netdev//' -e 's/_netdev//' -e 's/,r[ow],$//' -e 's/,r[ow],/,/' -e 's/^r[ow]$/defaults/' -e 's/$/,ro/')
physdev=$(findblockdevinsys "$rdev")
physdev=${physdev##*/dev/}
if [ -n "$physdev" ]; then
	vecho "Found root device $physdev for $rdev"
else
	physdev="$rdev"
fi

if [ -n "$physdev" -a "$physdev" != "$rdev" ]; then
	findstoragedriver ${physdev##/dev/}
fi

findstoragedriver ${rdev##/dev/}

for n in $basicmodules; do
    findmodule $n
done

for n in $CONFMODS; do
    findmodule $n
done

vecho "Using modules: $MODULES"

MNTIMAGE=`mktemp -d ${TMPDIR}/initrd.XXXXXX`
IMAGE=`mktemp ${TMPDIR}/initrd.img.XXXXXX`
RCFILE=$MNTIMAGE/init

if [ -z "$MNTIMAGE" -o -z "$IMAGE" ]; then
	error "Error creating temporaries.  Try again"
	exit 1
fi

mkdir -p $MNTIMAGE
mkdir -p $MNTIMAGE/firmware
mkdir -p $MNTIMAGE/lib/modules/$kernel
mkdir -p $MNTIMAGE/bin
mkdir -p $MNTIMAGE/etc
mkdir -p $MNTIMAGE/dev
mkdir -p $MNTIMAGE/lib
mkdir -p $MNTIMAGE/proc
mkdir -p $MNTIMAGE/sys
mkdir -p $MNTIMAGE/sysroot

vecho "Building initrd in $MNTIMAGE"

# Copy binaries over
inst /bin/echo "$MNTIMAGE"
inst /bin/sleep "$MNTIMAGE"
inst /bin/bash "$MNTIMAGE"
inst /bin/mount "$MNTIMAGE"
inst /bin/umount "$MNTIMAGE"
inst /bin/ls "$MNTIMAGE"
inst /bin/mknod "$MNTIMAGE"
inst /bin/mkdir "$MNTIMAGE"
inst /bin/chmod "$MNTIMAGE"
inst /bin/ln "$MNTIMAGE"
inst /bin/cat "$MNTIMAGE"
inst /bin/kill "$MNTIMAGE"
inst /bin/pidof "$MNTIMAGE"
inst /bin/rm "$MNTIMAGE"

inst /sbin/udevd "$MNTIMAGE"
inst /sbin/insmod "$MNTIMAGE"
inst /sbin/modprobe "$MNTIMAGE"
inst /sbin/switchroot "$MNTIMAGE"

inst /sbin/killall5 "$MNTIMAGE"
inst /sbin/udevadm "$MNTIMAGE"

inst /lib/udev/vol_id "$MNTIMAGE"

# symlink niceties
ln -s bash $MNTIMAGE/bin/sh

if [ -n "$excludemodules" ]; then
	MODULES=$(excludemods $MODULES)
	availmodules=$(excludemods $availmodules)
fi
resdeps MODULES
resmods="$resolved"
resdeps availmodules
for MODULE in $resmods $resolved; do
	installmodule $MODULE
done

mknod $MNTIMAGE/dev/ram0 b 1 0
mknod $MNTIMAGE/dev/ram1 b 1 1
ln -sf ram1 $MNTIMAGE/dev/ram

mknod $MNTIMAGE/dev/null c 1 3
mknod $MNTIMAGE/dev/zero c 1 5
mknod $MNTIMAGE/dev/systty c 4 0 
for i in 0 1 2 3 4 5 6 7 8 9 10 11 12 ; do
	mknod $MNTIMAGE/dev/tty$i c 4 $i
done
for i in 0 1 2 3 ; do
	mknod $MNTIMAGE/dev/ttyS$i c 4 $(($i + 64))
done
mknod $MNTIMAGE/dev/tty c 5 0
mknod $MNTIMAGE/dev/console c 5 1
mknod $MNTIMAGE/dev/ptmx c 5 2

echo -n >| $RCFILE
cemit << EOF
#!/bin/sh
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2008  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

export PATH=/sbin:/bin

mount -t proc /proc /proc
echo Mounting proc filesystem

# Silencing kernel
echo >/proc/sys/kernel/printk "1 4 1 7"

mount -t sysfs /sys /sys
echo Mounting sysfs filesystem

mount -o mode=0755 -t tmpfs /dev /dev
echo Creating /dev

mkdir /dev/pts
mount -t devpts -o gid=5,mode=620 /dev/pts /dev/pts

mkdir /dev/shm
mknod /dev/null c 1 3
mknod /dev/zero c 1 5
mknod /dev/systty c 4 0
mknod /dev/tty c 5 0
mknod /dev/console c 5 1
mknod /dev/ptmx c 5 2
EOF

# XXX really we need to openvt too, in case someting changes the
# color palette and then changes vts on fbcon before gettys start.
# (yay, fbcon bugs!)
for i in 0 1 2 3 4 5 6 7 8 9 10 11 12 ; do
	emit "mknod /dev/tty$i c 4 $i"
done

for i in 0 1 2 3 ; do
	emit "mknod /dev/ttyS$i c 4 $(($i + 64))"
done

cemit << EOF
/sbin/udevd --daemon
echo Creating initial device nodes
/sbin/udevadm trigger

echo Creating block device nodes.
/sbin/udevadm settle --timeout=30 || :
EOF

if [ "$scsi_wait_scan" == "yes" ]; then
	vecho "Adding module scsi_wait_scan"
	installmodule scsi_wait_scan
fi

depmod -a -b $MNTIMAGE $kernel
if [ $? -ne 0 ]; then
	error "\"depmod -a $kernel\" failed."
	exit 1
fi

usb_mounted="prep"
for MODULE in $MODULES; do
	text=""
	module=`echo $MODULE | sed -e "s|.*/||" -e "s/\.k\?o$//"`
	fullmodule=`echo $MODULE | sed "s|.*/||"`

	options=`sed -n -e ':a' -e '/\\\\$/N; s/\\\\\n//; ta' -e "s/^options[ 	][ 	]*$module[ 	][ 	]*//p" $modulefile 2>/dev/null`
    
	if [ -n "$options" ]; then
		vecho "Adding module $module$text with options $options"
	else
		vecho "Adding module $module$text"
	fi

	# we mount usbfs before the first module *after* the HCDs
	if [ "$usb_mounted" == "prep" ]; then
		if [[ "$module" =~ ".hci[_-]hcd" ]]; then
			usb_mounted="no"
		fi
	elif [ "$usb_mounted" == "no" ]; then
		if [[ ! "$module" =~ ".hci[_-]hcd" ]]; then
			usb_mounted=yes
			emit "mount -t usbfs /proc/bus/usb /proc/bus/usb"
		fi
	fi

	if [ -n "$options" ]; then
		echo "options $module $options" >> $MNTIMAGE/etc/modprobe.conf
	fi

	emit "echo \"Loading $module module\""
	emit "modprobe -q $module"
        
	# Hack - we need a delay after loading usb-storage to give things
	#        time to settle down before we start looking a block devices
	if [ "$module" = "usb-storage" -o "$module" = "ub" ]; then
		emit "echo Waiting for driver initialization."
		emit "#stabilized /proc/bus/usb/devices"
	fi
	# Firewire likes to change the subsystem name every 3 hours. :/
	if [ "$module" = "sbp2" ]; then
		emit "echo Waiting for driver initialization."
		emit "#stabilized /sys/bus/ieee1394/drivers/sbp2"
	fi
	if [ "$module" = "fw-sbp2" -o "$module" = "firewire-sbp2" ]; then
		emit "echo Waiting for driver initialization."
		emit "#stabilized /sys/bus/firewire/drivers/sbp2"
	fi
	if [ "${module::5}" == "pata_" -o "$module" == "ata_piix" -o "$module" == "ahci" -o "${module::5}" == "sata_" -o "$module" == "ibmvscsic" ]; then
		emit "echo Waiting for driver initialization."
		emit "#stabilized --hash --interval 250 /proc/scsi/scsi"
	fi
done
unset usb_mounted

if [ -n "$availmodules" ]; then
	cemit <<EOF
echo "Loading available PCI drivers"
loadDrivers
EOF
fi

cemit << EOF
echo '$rootdev /sysroot $rootfs $rootopts 0 0' > /etc/fstab

echo Mounting root filesystem.
mount /sysroot

# stopping udev daemon
kill \$(pidof udevd)

echo Switching to new root and running init.

exec switchroot $(get_verbose) /sysroot

echo exec switchroot failed...
bash
EOF

chmod +x $RCFILE

if [ "$dynamic" == "yes" ]; then
	vecho "This initrd uses dynamic shared objects."
	vecho "Adding dynamic linker configuration files."
	[ -n "$LD_SO_CONF" ] && inst "$LD_SO_CONF" "$MNTIMAGE" /etc/ld.so.conf
	#mkdir -p $MNTIMAGE/etc/ld.so.conf.d
	#for x in $(find $LD_SO_CONF_D -type f) ; do
	#	inst "$x" "$MNTIMAGE" "/etc/ld.so.conf.d/$(basename "$x")"
	#done

	vecho "Running ldconfig"
	ldconfig -r "$MNTIMAGE"
	if [ $? -ne 0 ]; then
		error tmpdir is $MNTIMAGE
		exit 1
	fi
fi

(cd $MNTIMAGE; findall . | cpio -H newc --quiet -o) >| $IMAGE || exit 1

gzip -9 < $IMAGE >| $target || rc=1
rm -rf $MNTIMAGE $IMAGE

exit $rc
