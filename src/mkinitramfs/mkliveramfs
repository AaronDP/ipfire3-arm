#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2008, 2009  Michael Tremer & Christian Schmidt                #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

. /usr/lib/mkinitramfs/functions

# Modules needed by the live system
MODULES="$MODULES aufs squashfs loop vfat ehci-hcd ohci-hcd uhci-hcd usb-storage"

# Add all storage modules
for module in /lib/modules/$KERNEL/kernel/drivers/{ata,message/fusion,pcmcia,scsi{,/*}}/*; do
	MODULES="$MODULES $(basename ${module/.ko})"
done

# Creating folders
mkdir -p mnt/{source,tmpfs,overlayfs,squashfs}

cat >> sbin/real-init <<'EOF'

netdevice=eth0

# Users can override rootfs target on the kernel commandline
for o in $(cat /proc/cmdline); do
	case $o in
	root=*)
		root=${o#root=}
		;;
	rootflags=*)
		rootflags=${o#rootflags=}
		;;
	rootfstype=*)
		rootfstype=${o#rootfstype=}
		;;
	net=*)
		net=${o#net=}
		;;
	netdevice=*)
		netdevice=${o#netdevice=}
		;;
	gateway=*)
		gateway=${o#gateway=}
		;;
	dns=*)
		dns="$dns ${o#dns=}"
		;;
	esac
done

# generate udev rules to generate /dev/root symlink
if [ -z $root ] ; then
	root=/dev/something
else
	case $root in
		/dev/disk/by-label/*)
			type="block"
			LABEL=${root#/dev/disk/by-label/}
			echo "SUBSYSTEM==\"block\", PROGRAM=\"/sbin/blkid -s LABEL -o value %N\", RESULT==\"$LABEL\", SYMLINK+=\"root\"" > /etc/udev/rules.d/00-label.rules
			if is_verbose; then
				echo "Added udev rule 00-label.rules:"
				cat /etc/udev/rules.d/00-label.rules
			fi
			type="block"
			;;
		CDLABEL=*)
			CDLABEL=${root#CDLABEL=}
			echo "KERNEL==\"hd[a-z]\", BUS==\"ide\", SYSFS{removable}==\"1\", ATTRS{media}==\"cdrom\", PROGRAM=\"/sbin/blkid -s LABEL -o value %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"root\"" > /etc/udev/rules.d/00-cdlabel.rules
			echo "KERNEL==\"sr[0-9]\", PROGRAM=\"/sbin/blkid -s LABEL -o value %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"root\"" >> /etc/udev/rules.d/00-cdlabel.rules
			echo "KERNEL==\"scd[0-9]\", PROGRAM=\"/sbin/blkid -s LABEL -o value %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"root\"" >> /etc/udev/rules.d/00-cdlabel.rules
			echo "KERNEL==\"pcd[0-9]\", PROGRAM=\"/sbin/blkid -s LABEL -o value %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"root\"" >> /etc/udev/rules.d/00-cdlabel.rules
			if is_verbose; then
				echo "Added udev rule 00-cdlabel.rules:"
				cat /etc/udev/rules.d/00-cdlabel.rules
			fi
			type="block"
			;;
		LABEL=*)
			LABEL=${root#LABEL=}
			echo "SUBSYSTEM==\"block\", PROGRAM=\"/sbin/blkid -s LABEL -o value %N\", RESULT==\"$LABEL\", SYMLINK+=\"root\"" > /etc/udev/rules.d/00-label.rules
			if is_verbose; then
				echo "Added udev rule 00-label.rules:"
				cat /etc/udev/rules.d/00-label.rules
			fi
			type="block"
			;;
		/dev/disk/by-id/*)
			UUID=${root#/dev/disk/by-id/}
			echo "SUBSYSTEM==\"block\", PROGRAM=\"/sbin/blkid -s UUID -o value %N\", RESULT==\"$UUID\", SYMLINK+=\"root\"" > /etc/udev/rules.d/01-uuid.rules
			if is_verbose; then
				echo "Added udev rule 01-uuid.rules:"
				cat /etc/udev/rules.d/01-uuid.rules
			fi
			type="block"
			;;
		UUID=*)
			UUID=${root#UUID=}
			echo "SUBSYSTEM==\"block\", PROGRAM=\"/sbin/blkid -s UUID -o value %N\", RESULT==\"$UUID\", SYMLINK+=\"root\"" > /etc/udev/rules.d/01-uuid.rules
			if is_verbose; then
				echo "Added udev rule 01-uuid.rules:"
				cat /etc/udev/rules.d/01-uuid.rules
			fi
			type="block"
			;;
		http://*|https://*|ftp*://*|ftps://*|scp://*|sftp://*)
			thingtofetch="${root}"
			type="download"

			# When doing http(s) transfers, compress the data
			if [ "${thingtofetch:0:4}" = "http" ]; then
				curloptions="--compressed"
			fi
			;;
		/dev/*)
			ln -s $root /dev/root
			type="block"
			;;
		*)
			thingtomount=$root
			;;
	esac
fi

if [ "$type" = "block" ]; then
	thingtomount=/dev/root

elif [ "$type" = "download" ]; then
	rootflags="loop"
	thingtomount=/${thingtofetch##*/}

	# If no network configuration was given,
	# we'll try dhcp
	if [ -z "${net}" ]; then
		net="dhcp"
	fi
fi

echo "udev_log=\"error\"" >> /etc/udev/udev.conf

# rules for loading modules
echo -n "ACTION==\"add\", SUBSYSTEM==\"?*\", ENV{MODALIAS}==\"?*\", RUN+=\"/sbin/modprobe $" >> /etc/udev/rules.d/10-modprobe.rules
echo "env{MODALIAS}\"" >> /etc/udev/rules.d/10-modprobe.rules
echo "ACTION==\"add\", SUBSYSTEM==\"scsi_device\" RUN+=\"/sbin/modprobe sg\"" >> /etc/udev/rules.d/10-modprobe.rules
echo "ACTION==\"add\", SUBSYSTEM==\"scsi_device\", SYSFS{type}==\"0|7|14\", RUN+=\"/sbin/modprobe sd_mod\"" >> /etc/udev/rules.d/10-modprobe.rules
echo "ACTION==\"add\", SUBSYSTEM==\"scsi_device\", SYSFS{type}==\"[45]\", RUN+=\"/sbin/modprobe sr_mod\"" >> /etc/udev/rules.d/10-modprobe.rules
echo "SUBSYSTEM==\"mmc\", RUN+=\"/sbin/modprobe mmc_block\"" >> /etc/udev/rules.d/10-modprobe.rules

if [ "${type}" = "block" ]; then
	# FIXME: hack since sr_mod seems to fail to get loaded sometimes (#239657)
	modprobe sr_mod
fi

modprobe loop max_loop=16

vecho "Starting udevd..."
udevd --daemon

vecho "Creating devices..."
udevadm trigger

if [ "${type}" = "download" ]; then
	# Wait 30 seconds for network to appear.
	COUNTDOWN=30
	while [ "x$COUNTDOWN" != "x0" ] ; do
		is_verbose && echo -n "."
	
		if ip link show $netdevice &>/dev/null; then
			COUNTDOWN=0
			continue
		fi

		COUNTDOWN=$(($COUNTDOWN - 1))
		sleep 1
	done
	vecho # Blank line

	ip link set $netdevice up
	if [ "$net" = "dhcp" ]; then
		vecho "Getting an IP address by DHCP..."
		dhclient $(get_verbose) $netdevice
	else
		vecho "Setting IP address $net..."
		ip addr add $net dev $netdevice
	fi
	if [ -n "$gateway" ]; then
		vecho "Setting default gateway $gateway..."
		ip route add default via $gateway
	fi
	if [ -n "$dns" ]; then
		vecho "Setting up dns server $dns..."
		echo "nameserver $dns" > /etc/resolv.conf
	fi
	if [ -n "$gateway" ]; then
		vecho "Pinging gateway $gateway..."
		if ! ping -c3 -w10 $gateway &>/dev/null; then
			echo "This box does not seem to have a connection"
			echo "to the default gateway $gateway."
			echo "You may fix this now and continue then:"
			echo
			bash
		fi
	fi
fi

if [ "$type" = "download" ]; then
	curloptions="${curloptions} --connect-timeout 30 --progress-bar --output ${thingtomount}"
	#curloptions="${curloptions} --write-out=\"Fetched %{url_effective} in %{time_total}s (%{speed_download} bytes/s).\""

	vecho "Running donwload..."
	vecho "  $thingtofetch"

	curl ${curloptions} ${thingtofetch}

	if [ "$?" != "0" ]; then
		echo "An error occured when fetching ${thingtomount}:"
		echo "  Command: ${curl} ${thingtofetch}"
		echo
		echo "You now get a shell to download the file manually."
		echo "Exit to continue booting."
		echo
		bash
	fi
fi

if [ "$SHELL" == "1" ] ; then
	echo "Shell requested on kernel commandline. Exit to continue booting."
	echo
	bash
fi

if [ "${type}" = "block" ]; then
	# Wait 90 seconds for $thingtomount to appear.
	COUNTDOWN=90
	while [ "x$COUNTDOWN" != "x0" ] ; do
		is_verbose && echo -n "."

		if [ -e $thingtomount ]; then
			COUNTDOWN=0
			continue
		fi
		# this is kind of lame, but we could have had a situation
		# where we were unable to read the volume id.  so trigger
		# another run through the block devs
		if [ "x$COUNTDOWN" = "x30" ]; then
			udevadm trigger --subsystem-match=block
		fi
	
		COUNTDOWN=$(($COUNTDOWN - 1))
		sleep 1
	done
	vecho # Blank line
fi

if [ ! -e $thingtomount ] ; then
	echo
	echo "--------------------------------------"
	echo "WARNING: Cannot find root file system!"
	echo "--------------------------------------"
	echo
	echo "Create symlink $thingtomount and then exit this shell to continue"
	echo "the boot sequence."
	echo
	bash
fi

if is_verbose; then
	vecho "Mounting $thingtomount..."
	ls -lh $thingtomount
fi

if [ "x$READONLY" == "x1" ] ; then
	rootflags="$rootflags,ro"
else
	rootflags="$rootflags,rw"
fi

if [ -n $rootflags ]; then
	mountoptions=" -o$rootflags"
fi

[ -n "$rootfstype" ] && rootfstype="-t $rootfstype"

mount -n $rootfstype $mountoptions $thingtomount /mnt/source

if [ "$?" != "0" ]; then
	echo "---------------------------------"
	echo "WARNING: Cannot mount rootfs!"
	echo "---------------------------------"
	echo
	echo "Dropping to a shell. "
	echo "Mount /mnt/source and exit shell to continue. Good luck!"
	echo
	bash
fi

mount -n -t tmpfs none /mnt/tmpfs
aufsmountoptions="br:/mnt/tmpfs=rw"

count=0
for overlay in $(find /mnt/source -name "*.overlay" 2>/dev/null); do
	vecho "Setting up overlay ${overlay}..."
	mkdir -p /mnt/overlay${count} 2>/dev/null
	mount -n -t squashfs -o loop,ro ${overlay} /mnt/overlay${count}
	aufsmountoptions="$aufsmountoptions:/mnt/overlay${count}=rr"
	count=$((${count} + 1))
done

count=0
for sfs in $(find /mnt/source -name "*.sfs" 2>/dev/null); do
	vecho "Setting up squashed fs ${sfs}..."
	mount -n -t squashfs -o loop,ro ${sfs} /mnt/squashfs
	aufsmountoptions="$aufsmountoptions:/mnt/squashfs=rr"
	break
done

mount -t aufs -o $aufsmountoptions none /sysroot

for i in $(cd /mnt; ls); do
	mountpoint /mnt/$i >/dev/null || continue
	mkdir -p /sysroot/mnt/$i || :
	mount --move /mnt/$i /sysroot/mnt/$i
done

# Shutting down network
if [ "${type}" = "download" ]; then
	if [ "${net}" = "dhcp" ]; then
		kill $(pidof dhclient)
	else
		ip address flush dev ${netdevice}
	fi
	ip link set ${netdevice} down
	ip route flush table main
fi

if [ "$ESHELL" == "1" ]; then
	echo "Shell requested on kernel commandline."
	echo "Rootfs is mounted ro on /sysroot. Exit to continue booting."
	echo
	bash
fi

if [ -x /sysroot$init ]; then
	# Leave initramfs and transition to rootfs
	kill $(pidof udevd)
	vecho "Transfering control to $init"

	exec switch_root /sysroot ${init}
	echo "---------------------------------"
	echo "WARNING: Error switching to real rootfs!"
	echo "---------------------------------"
	echo
	echo "Dropping to a shell. Good luck!"
	echo
	bash
else
	echo "---------------------------------------------------------"
	echo "WARNING: Requested $init binary does not exist on rootfs."
	echo "---------------------------------------------------------"
	echo
	echo "Dropping to a shell. Good luck!"
	echo
	bash
fi

EOF

finalize
