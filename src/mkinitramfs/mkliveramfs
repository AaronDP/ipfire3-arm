#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2008, 2009  Michael Tremer & Christian Schmidt                #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

. /usr/lib/mkinitramfs/functions

# Modules needed by the live system
MODULES="$MODULES aufs squashfs loop"

# Add all storage modules
for module in /lib/modules/$KERNEL/kernel/drivers/{ata,message/fusion,pcmcia,scsi{,/*}}/*; do
	MODULES="$MODULES $(basename ${module/.ko})"
done
## XXX need to add support for usb cdroms

# Creating folders
mkdir -p mnt/{source,tmpfs,overlayfs,squashfs}

cat >> sbin/real-init <<'EOF'
# Users can override rootfs target on the kernel commandline
for o in $(cat /proc/cmdline); do
	case $o in
	root=*)
		root=${o#root=}
		;;
	rootflags=*)
		rootflags=${o#rootflags=}
		;;
	rootfstype=*)
		rootfstype=${o#rootfstype=}
		;;
	esac
done

# generate udev rules to generate /dev/root symlink
if [ -z $root ] ; then
	root=/dev/something
else
	case $root in
		/dev/disk/by-label/*)
			LABEL=${root#/dev/disk/by-label/}
			echo "SUBSYSTEM==\"block\", PROGRAM=\"/lib/udev/vol_id -l %N\", RESULT==\"$LABEL\", SYMLINK+=\"root\"" > /etc/udev/rules.d/00-label.rules
			if is_verbose; then
				echo "Added udev rule 00-label.rules:"
				cat /etc/udev/rules.d/00-label.rules
			fi
			thingtomount=/dev/root
			;;
		CDLABEL=*)
			CDLABEL=${root#CDLABEL=}
			echo "KERNEL==\"hd[a-z]\", BUS==\"ide\", SYSFS{removable}==\"1\", ATTRS{media}==\"cdrom\", PROGRAM=\"/lib/udev/vol_id -l %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"root\"" > /etc/udev/rules.d/00-cdlabel.rules
			echo "KERNEL==\"sr[0-9]\", PROGRAM=\"/lib/udev/vol_id -l %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"root\"" >> /etc/udev/rules.d/00-cdlabel.rules
			echo "KERNEL==\"scd[0-9]\", PROGRAM=\"/lib/udev/vol_id -l %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"root\"" >> /etc/udev/rules.d/00-cdlabel.rules
			echo "KERNEL==\"pcd[0-9]\", PROGRAM=\"/lib/udev/vol_id -l %N\", RESULT==\"$CDLABEL\", SYMLINK+=\"root\"" >> /etc/udev/rules.d/00-cdlabel.rules
			if is_verbose; then
				echo "Added udev rule 00-cdlabel.rules:"
				cat /etc/udev/rules.d/00-cdlabel.rules
			fi
			thingtomount=/dev/root
			;;
		LABEL=*)
			LABEL=${root#LABEL=}
			echo "SUBSYSTEM==\"block\", PROGRAM=\"/lib/udev/vol_id -l %N\", RESULT==\"$LABEL\", SYMLINK+=\"root\"" > /etc/udev/rules.d/00-label.rules
			if is_verbose; then
				echo "Added udev rule 00-label.rules:"
				cat /etc/udev/rules.d/00-label.rules
			fi
			thingtomount=/dev/root
			;;
		/dev/disk/by-id/*)
			UUID=${root#/dev/disk/by-id/}
			echo "SUBSYSTEM==\"block\", PROGRAM=\"/lib/udev/vol_id -u %N\", RESULT==\"$UUID\", SYMLINK+=\"root\"" > /etc/udev/rules.d/01-uuid.rules
			if is_verbose; then
				echo "Added udev rule 01-uuid.rules:"
				cat /etc/udev/rules.d/01-uuid.rules
			fi
			thingtomount=/dev/root
			;;
		UUID=*)
			UUID=${root#UUID=}
			echo "SUBSYSTEM==\"block\", PROGRAM=\"/lib/udev/vol_id -u %N\", RESULT==\"$UUID\", SYMLINK+=\"root\"" > /etc/udev/rules.d/01-uuid.rules
			if is_verbose; then
				echo "Added udev rule 01-uuid.rules:"
				cat /etc/udev/rules.d/01-uuid.rules
			fi
			thingtomount=/dev/root
			;;
		/dev/*)
			ln -s $root /dev/root
			thingtomount=$root
			;;
		*)
			thingtomount=$root
			;;
	esac
fi

echo "udev_log=\"error\"" >> /etc/udev/udev.conf

# rules for loading modules
echo -n "ACTION==\"add\", SUBSYSTEM==\"?*\", ENV{MODALIAS}==\"?*\", RUN+=\"/sbin/modprobe $" >> /etc/udev/rules.d/10-modprobe.rules
echo "env{MODALIAS}\"" >> /etc/udev/rules.d/10-modprobe.rules
echo "ACTION==\"add\", SUBSYSTEM==\"scsi_device\" RUN+=\"/sbin/modprobe sg\"" >> /etc/udev/rules.d/10-modprobe.rules
echo "ACTION==\"add\", SUBSYSTEM==\"scsi_device\", SYSFS{type}==\"0|7|14\", RUN+=\"/sbin/modprobe sd_mod\"" >> /etc/udev/rules.d/10-modprobe.rules
echo "ACTION==\"add\", SUBSYSTEM==\"scsi_device\", SYSFS{type}==\"[45]\", RUN+=\"/sbin/modprobe sr_mod\"" >> /etc/udev/rules.d/10-modprobe.rules
echo "SUBSYSTEM==\"mmc\", RUN+=\"/sbin/modprobe mmc_block\"" >> /etc/udev/rules.d/10-modprobe.rules

# FIXME: hack since sr_mod seems to fail to get loaded sometimes (#239657)
modprobe sr_mod

modprobe loop max_loop=16

vecho "Starting udevd..."
udevd --daemon

vecho "Creating devices..."
udevadm trigger

vecho "Waiting for system to settle..."
udevadm settle --timeout=30 || :

if [ "$SHELL" == "1" ] ; then
	echo "Shell requested on kernel commandline. Exit to continue booting."
	echo
	bash
fi

# Wait 60 seconds for /dev/root to appear.
COUNTDOWN=60
while [ "x$COUNTDOWN" != "x0" ] ; do
	is_verbose && echo -n "."

	if [ -e /dev/root ]; then
		COUNTDOWN=0
		continue
	fi
	# this is kind of lame, but we could have had a situation
	# where we were unable to read the volume id.  so trigger
	# another run through the block devs
	if [ "x$COUNTDOWN" = "x30" ]; then
		udevadm trigger --subsystem-match=block
	fi

	COUNTDOWN=$(($COUNTDOWN - 1))
	sleep 1
done
vecho # Blank line

if [ ! -b /dev/root ] ; then
	echo
	echo "--------------------------------------"
	echo "WARNING: Cannot find root file system!"
	echo "--------------------------------------"
	echo
	echo "Create symlink /dev/root and then exit this shell to continue"
	echo "the boot sequence."
	echo
	bash
fi

if is_verbose; then
	vecho "Mounting /dev/root..."
	ls -l /dev/root
fi

if [ "x$READONLY" == "x1" ] ; then
	rootflags="$rootflags,ro"
else
	rootflags="$rootflags,rw"
fi

if [ -n $rootflags ]; then
	mountoptions=" -o$rootflags"
fi

mount -n -t $rootfstype $mountoptions $thingtomount /mnt/source
RES=$?

if [ "$RES" != "0" ]; then
	echo "---------------------------------"
	echo "WARNING: Cannot mount rootfs!"
	echo "---------------------------------"
	echo
	echo "Dropping to a shell. "
	echo "Mount /mnt/source and exit shell to continue. Good luck!"
	echo
	bash
fi

mount -n -t tmpfs none /mnt/tmpfs
aufsmountoptions="br:/mnt/tmpfs=rw"

OVERLAY=$(ls /mnt/source/*.overlay 2>/dev/null || true)
if [ -n "$OVERLAY" ]; then
	vecho "Setting up overlay for squashfs..."
	mount -t squashfs -o loop,ro $OVERLAY /mnt/overlayfs
	aufsmountoptions="$aufsmountoptions:/mnt/overlayfs=rr"
fi

SQUASHED=$(ls /mnt/source/*.img 2>/dev/null || true)
if [ -n "$SQUASHED" ] ; then
	vecho "Setting up embedded squashfs..."
	mount -t squashfs -o loop,ro $SQUASHED /mnt/squashfs
	aufsmountoptions="$aufsmountoptions:/mnt/squashfs=rr"
fi

mount -t aufs -o $aufsmountoptions none /sysroot

for i in $(cd /mnt; ls); do
	mountpoint /mnt/$i >/dev/null || continue
	mkdir -p /sysroot/mnt/$i || :
	mount --move /mnt/$i /sysroot/mnt/$i
done

if [ "$ESHELL" == "1" ]; then
	echo "Shell requested on kernel commandline."
	echo "Rootfs is mounted ro on /sysroot. Exit to continue booting."
	echo
	bash
fi

if [ -x /sysroot$init ]; then
	# Leave initramfs and transition to rootfs
	kill $(pidof udevd)
	vecho "Transfering control to $init"

	exec switchroot $(get_verbose) /sysroot
	echo "---------------------------------"
	echo "WARNING: Error switching to real rootfs!"
	echo "---------------------------------"
	echo
	echo "Dropping to a shell. Good luck!"
	echo
	bash
else
	echo "---------------------------------------------------------"
	echo "WARNING: Requested $init binary does not exist on rootfs."
	echo "---------------------------------------------------------"
	echo
	echo "Dropping to a shell. Good luck!"
	echo
	bash
fi

EOF

finalize
